{
    "episodios": [
        {
            "data": "2017-11-30T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Lançamento do podcast! Você já ouviu falar sobre Atomic Design?"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep1-atomic-design.mp3",
            "duracao": "08:41",
            "texto": "Oi!\n\nEste é o primeiro episódio de um podcast sobre programação que está em construção.\nSe você estiver ouvindo pelo browser, pode perceber o que eu estou dizendo só de olhar para a página onde está o player.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo de no máximo 10 minutos toda semana. O objetivo aqui é aprender ainda mais sobre programação.\nFalaremos sobre front-end, javascript, css, html5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional e uma vida como programador organizada em elementos...\nEu inicío esse podcast hoje já falando de um tema que tenho gostado muito e gostaria de compartilhar com você como tem sido desenvolver no front de forma atômica e pra isso, precisamos começar falando diretamente sobre uma metodologia de projeto que me agrada muito, o Atomic Design.\nSe você nunca ouviu falar sobre isso, eu te digo de uma forma simples rápida:\n\nAtomic Design nada mais é do que uma forma de desenhar projetos.\nSeja na documentação, no layout, na forma com que criamos os testes, como separamos os arquivos, como pensamos nas funcionalidades do programa, na forma com que vamos reusar o código, entre outros.\nExistem diversas outras formas de fazer isso, algumas bem conhecidas são DDD e SOLID. Você pode ter lembrado do famoso MVC também, porém, ele não entra nesse caso já que o padrão MVC não é um design pattern propriamente dito.\nEu escolhi Atomic Design porque me deparei com o fato de que eu consigo levar essa maneira de pensar pra quase qualquer coisa que esteja relacionada a forma com que eu programo algo.\n\nDurante os próximo episódios nós conversaremos a fundo sobre como funciona isso e teremos uma série especializada no tema. Descobriremos qual tecnologia usar e como  chegar na conclusão de que nosso software precisa ser componentizado, atômico e reativo.\nNas próximas semanas também, eu terei aqui comigo, alguns amigos que nos ajudarão a entender ainda mais alguns dos temas que eu citei logo no início.\nNeste primeiro episódio eu irei explanar superficialmente os conceitos básicos de Atomic Design, mas pra isso, precisamos de teoria e vamos voltar um pouco nos tempos da escola pra falarmos sobre um assunto muito antigo mas completamente atual.\n\nSegundo a Wikipédia, em física e química, modelo atômico é todo modelo científico que se usa para explicar os átomos e seus comportamentos.\nNo século V antes de Cristo, alguns filósofos defendiam o atomismo, pois acreditavam que dividindo a matéria em pedaços cada vez menores, seria possível encontrar partículas que seriam invisíveis ao olho humano e, segundo esses pensadores, os átomos filosóficos vêm em uma variedade infinita de formas e tamanhos cada uma delas sendo indestrutíveis, imutáveis e cercadas por um vazio onde colidem com outras partículas ou se reúnem em algo que hoje chamamos de moléculas, organismos e matéria.\n\nPartindo desse princípio, nasceu a proposta de que o todo, se compõe não só de átomos ou partículas indivisíveis de natureza idêntica. Aí então nasceu a teoria da unidade e imutabilidade do ser.\nAcredita-se que vácuo e matéria desde a eternidade interagem entre si dando origem ao movimento, e que os átomos apresentam as propriedades de: forma, movimento, tamanho e impenetrabilidade, e, por meio de choques entre si, dão origem a objetos.\nUm desses filósofos, defendia que a matéria era descontínua, portanto, ao invés dos corpos macroscópicos que nós vemos, os corpos microscópicos ou os átomos não podem ocupar o mesmo espaço no tempo nem podem ser divididos, sendo suas mudanças observadas em fenômenos físicos e químicos como por exemplo a junção ou separação dos átomos e que qualquer matéria é resultado da combinação dos átomos dos quatro elementos básicos: ar; fogo; água e terra.\n\nTá, e o que programação tem a ver com nisso?\n\nO criador do Atomic Design, Brad Frost, desenhou cinco camadas básicas de divisão unindo todo esse conceito aí que você ouviu agora. No pensamento dele, nosso software pode ser separado por ÁTOMOS, MOLÉCULAS, ORGANISMOS, TEMPLATES e PÁGINAS.\nE há pouco tempo atrás, estudando mais sobre a metodologia, eu encontrei lugar para mais dois elementos os BÓSONS e os QUARKS.\nEu vou explicar um por um, relaxa.\n\nÁTOMO\nUm elementos mínimo presente em uma interface gráfica.\nNo mundo dos componentes eles são labels, inputs, campos de formulário, botões, títulos, parágrafos, etc.\n\nMOLÉCULA\nSão dois ou mais átomos mantidos juntos para funcionarem com um propósito único.\nUma molécula seria então um input junto com um botão que juntos, tem a função de busca numa interface gráfica.\n\nORGANISMOS\nNaturalmente, são duas ou mais moléculas que começam a moldar a navegação e a leitura do conteúdo nessa interface.\nAumentando o exemplo, a molécula de busca ao lado da molécula de navegação e do logotipo, faz parte do organismo header.\n\nTEMPLATES\nBom, você já deve ter entendido que estamos falando cada vez mais sobre abstrações da interface, né? Os templates consistem em vários organismos combinados para formar páginas.\n\nPÁGINAS\nE as páginas são uma evolução natural dos templates. Ou seja, são os layouts em si.\nLembra que eu disse que encontrei o caso de uso pra mais dois elementos?\n\nBÓSONS\nSão aquelas “coisinhas” que fazem uma grande diferença no visual e legibilidade de uma interface. Eles não precisam ser literalmente visíveis, pois são abstratos, como paletas de cores, fontes, animações e aspectos ainda mais invisíveis de uma interface como grids.\n\nQUARKS\nUm cara desses nunca é encontrado isoladamente, isto significa que um Quark só existirá quando existir um elemento completo.\nComo por exemplo, itens que enviam feedback para o usuário, como barras de progresso ou rolagem, validações em formulário, hints, dicas, tips de ajuda e etc...\n\nOu seja, imagina agora que tudo isso junto na mesma página tem uma vida própria, um escopo muito reduzido e uma capacidade natural de interagir entre si. Como cada item desse é um componente vivendo no seu app, você precisa ter um orquestrador, digamos assim, e é aí que entra o conceito de controle de estados imutáveis e reatividade entre todos os componentes... \n\nAfinal, quando você clicar no átomo de botão que está dentro da molécula de busca, o organismo de conteúdo precisará ser atualizado dentro do template de pesquisa para renderizar a página com o resultado...\n\nTá... Acho que agora você deve estar pensando em que é coisa pra caramba pra controlar e que é muito difícil abstrair tudo e começar a pensar assim... Bom... Eu preciso te dizer que não, é bem pelo contrário... Imagina que como eu disse agora pouco, o mundo funciona assim, a natureza rege tudo dessa maneira, então cabe a nós darmos continuidade na forma natural da vida dentro do nosso mundo digital.\nQuando você fizer isso, vai começar a perceber e será natural a aplicação de vários conceitos de programação funcional (que falaremos em breve), funções puras, códigos explícitos, escopos mínimos, reatividade natural, componentização obrigatória e também da coisa mais desejada de todos os programadores e gestores de TI... \n\nREÚSO DE CÓDIGO DE VERDADE!\n\nEu te garanto que a partir do momento que você decidir usar Atomic Design no seu dia a dia como programador, sua produtividade aumentará absurdamente.\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\nUma comunidade forte, é uma comunidade unida que se ajuda.\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2017-12-07T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Tá, quero separar tudo em componentes! Como ficam os entregáveis? Os arquivos mesmo..."
            },
            "subtitulo": "Parte 2",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep2-atomic-design.mp3",
            "duracao": "12:12",
            "texto": "Oi!\n\nEste é o segundo episódio de um podcast sobre programação que continua em construção.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo toda semana.\nAntes de começar hoje, eu preciso agradecer muito a cada um que parou o que estava fazendo pra me ouvir e interagir comigo nos últimos dias... Foram inúmeros feedbacks positivos e foi surpreendente ver a quantidade de pessoas que se interessaram pelo assunto! Fico feliz em saber que vamos trilhar um caminho legal pela frente. Então já sabe, vem trocar ideia comigo em alguma das minhas redes sociais que estão no site do ELEMENCAST.\nUm dos feedbacks que eu recebi é que só dei exemplos de uso do Atomic Design em interfaces gráficas e aí o pessoal que manda bem em NodeJS e outras soluções pra backend e que não é muito feliz com CSS e design, ficou meio sem ver o valor que a metodologia poderia ter no back. Eu preciso dizer que sim, Atomic Design pode ter um lugar aí no seu coraçãozinho sem layout no back também.\n\nNo primeiro episódio, eu falei de uma forma bem básica e suave o conceito principal do Atomic Design. Hoje, eu vou aprofundar um pouco mais, tratando a forma que ficam os entregáveis, como é a interação do time durante o desenvolvimento do sistema e qual é o papel de cada um no processo de criação do app, também vou falar um pouquinho mais de programação funcional também, afinal pra mim, Atomic Design e programação funcional, são almas gêmeas.\nO lance principal é que a metodologia pretende te forçar a pensar em abstração de código e te fazer olhar sempre pra menor parte do app e ir 'subindo'...\n\nSe você está construindo uma API Rest em NodeJS com Express por exemplo, você pode pensar que sua rota tem uma função e essa função é uma página (lembre-se que página aqui não é literalmente uma que poderá ser renderizada por sua rota e sim o elemento de abstração mais alto do Atomic Design a função em si).\nAgora pense que essa função só tem uma obrigação, chamar as outras funções que constroem o 'template' passando os parâmetros da rota. Só aqui, já começamos a ter funções puras e modularização natural. O template seria o conteúdo principal, uma espécie de core da sua rota e dentro dele, nós chamaremos as funções 'menores' digamos assim passando mais parâmetros, até chegar naquela sua função que tem o único propósito de devolver um array filtrado de dados, por exemplo.\n\nPercebe que só de termos chegado nessa função minúscula de filtrar um array, já nos deparamos com uma situação que nos fará escrever um código com mais qualidade e que isso será completamente natural e involuntário... Uma função que filtra um array é automaticamente reusável. É uma função pura que tem um escopo muito reduzido, um input explícito (que seria o nosso array bruto) e um output explícito (que será o array filtrado).\n\nParece até chato ficar repetindo isso de função pura e etc, mas é que eu realmente quero que isso fique fixado na sua mente e que você não pare de pensar nisso. Assim que você ver o seu código, quero que você fique com vontade de refatorar aquela função gigante que você escreveu ontem e que manipula 10 objetos globais...\nEsse inclusive é aquele momento ótimo pra você aprender a não usar mais for's e while's... Sim, essa vida de loops não te pertence mais... Nós podemos fazer 99,99% de todos os loops de dados usando as três funções principais de iteração map, filter e reduce.\nVocê já deve ter visto essas três palavrinhas em algum lugar da web que falava de ES6 ou das novidades de Javascript...\nTem muito artigo bom na internet sobre isso e eu recomendo fortemente o artigo do Vinicius Reis que tem o título: “Reduce, mais um dia sem loops.”. Você pode encontrar esse artigo facilmente lá no Medium ou usando seu buscador favorito. Em breve, eu abordarei cada um desses temas aí, assim, aprenderemos como é isso de viver sem loops.\n\nVocê só não pode esquecer de fazer uma função genérica com inputs e outputs definidos e com isso automaticamente você estará fazendo um código reusável e que não gera efeitos colaterais em outras partes do seu app.\n\nEFEITOS COLATERAIS? COMASSIM?\n\nToda função que não é pura, ou seja, que manipula um valor dentro dela que não foi passado por um parâmetro, está alterando um pedaço fora do escopo dela mesmo. Ou seja, está provocando um efeito colateral em algo que talvez você não queira... Se uma variável global define uma URL e você altera esse endereço dentro da função, todas as outras funções receberão esse valor alterado e isso poderá te gerar um problema sem tamanho... Sem contar que manipular dados assim, tiram qualquer característica de reuso dessa função... Você terá de escrever sempre uma função nova pra fazer coisas diferentes só que fazendo a mesma coisa...\nReuso de código é um desejo de todos! Sempre foi... Escrever menos, produzir mais, produzir melhor, produzir sempre\nE para que essas funções todas sejam reusáveis você precisará modularizar seu código inteiro, então logo nós teremos vários arquivos com poucas linhas de código que serão módulos exportando código pra outros módulos e em algum momento, você terá uma função que passa outra função como parâmetro para receber um valor lá de longe. E toda vez que você fizer isso, estará criando e usando alguns conceitos de programação funcional como High Order Function, First Class Function e Lambda Function. Se você não sabe o que são esses temas, pode ficar sossegado porque em um dos próximos episódios nós abordaremos esse assunto com quem manja de verdade.\n\nEssa forma de programar e pensar em módulos já é uma realidade no front e no back. Se você usa React, Vue, Angular, Mithrill ou qualquer outro framework JS com algum pré-processador de arquivos como Webpack, Rollup, Browserify, Gulp ou Grunt, você sabe do que estou falando.\nA facilidade de importar e exportar códigos e fazer essa conexão entre arquivos não se limita a Javascript, várias outras tecnologias de front também possuem essa capacidade. Por exemplo SASS, Stylus e LESS que são pré-processadores de CSS e a linguagem de templates PUG fazem importação de módulos desde sempre. E particularmente, quem me conhece sabe o quanto eu adoro PUG e SASS.\n\nLembre-se, não é obrigatório seguir o fluxo proposto pelo Atomic Design de 'página > template > organismo > molécula > átomo'. Se você precisar ir de 'página' pra 'átomo' diretamente, tudo bem! Só não esqueça que o fluxo do dado é sempre do menor para o maior e que as chamadas das funções partem sempre das maiores pras menores. Ou seja, você não pode fazer um átomo chamar outro átomo que chama outro átomo, que chama mais um outro átomo... Não faz sentido isso... Você precisa orquestrar essas chamadas.\n\nMas então e esse monte de arquivinhos espalhados na minha pasta SOURCE, e agora? O ATOMIC DESIGN é bem flexível quanto a isso e o que eu vou te falar aqui agora é o jeito que EU faço, é a MINHA preferência pessoal e eu te indico fortemente essa maneira, pois ela é um catado geral de vários projetos que eu já acompanhei sendo criados com a metodologia e a soma da experiência que eu já tive fazendo projetos por onde passei.\nDentro do seu diretório 'source' ('/src'), crie um sub-diretório chamado 'componentes' e dentro dele crie mais alguns sub-diretórios chamados 'atomos', 'moleculas', 'organismos', 'templates' e 'paginas', assim mesmo, no plural. Se você preferir, pode criar em inglês também, lembre-se que essa é uma escolha totalmente sua, o mais importante aqui é saber diferenciar a hierarquia das coisas, o seu código dentro desses diretórios é mais importante do que o nome deles em si. No seu bundle, essas pastas não terão nenhum valor, então foca na funcionalidade!\n\nO conteúdo de cada um desses diretórios poderá ser outros diretórios nomeando os componentes e isso quem controlará será você, seu framework e o seu time. Como por exemplo, se você está desenvolvendo um webapp com VueJS, você 'não precisa' de pastas. Os 'Vue Single File Components' já contém tudo relacionado ao seu componente. Porém, se estiver usando React com SASS ou Angular com HTML e CSS externos, terá de criar uma pasta para cada componente e dentro dela, todos os arquivos relacionados a ele.\nÉ válido lembrar que se você criar diretórios para cada componente o restante do time poderá atuar individualmente em cada um deles, já que a metodologia visa integrar equipes inteiras e agilizar a entrega de protótipos, wireframes e layouts para que todos tenham tempo de focar em partes específicas, estratégicas e na qualidade do código que será entregue ao cliente.\nComo por exemplo, a equipe destinada a documentar o código poderá colocar o arquivo Markdown da documentação do componente dentro da sua respectiva pasta. O designer poderá colocar o arquivo JPG de como deverá ser o layout do componente no final, O Dev que gosta de escrever os testes poderá deixar o arquivo '.spec' dele lá dentro também e assim sucessivamente... Tudo que for relacionado a esse componente deve estar dentro da pasta dele.\nNo lugar de serem entregues inúmeros arquivos em PSD ou JPG pro cliente ficar aprovando e depois os Devs ficarem fatiando e refazendo a cada alteração, você vai conseguir concentrar tudo num repositório de padrões de interações que serão usadas pelo webapp e com as interações já funcionando. Afinal, cada componente tem vida própria, lembra? Eles são independentes e estarão funcionando de forma ordenada, em conjunto com o todo. Mesmo se eles não possuírem lógica, como por exemplo se foram apenas de HTML e CSS você já terá uma noção real de como ficará o app em diversos tamanhos de telas, como serão as animações e etc...\n\nSim, serão muitos arquivos. Esteja preparado pra isso. Tenha em mente o lado positivo da coisa, você terá uma responsabilidade menor de código com cada um deles e acima de tudo está construindo um código escalável tanto no layout quanto em documentação, testes, performance, qualidade e legibilidade de código por estar sempre pensando do menor para o maior e com isso, atingindo todas as áreas.\nParticularmente também, você pode escolher pular alguma dessas etapas, como por exemplo, as vezes eu não crio nenhum componente do tipo 'página'. Dependendo do projeto, os componentes do tipo 'template' são suficientes. Então, se você se deparar com uma necessidade de pular alguma camada mais alta de abstração, fique a vontade. Você só não poderá pular a etapa dos 'átomos', pois ela é a base de tudo. Lembre-se, Atomic Design te fazer olhar de baixo pra cima, do menor pro maior. É importante frisar isso.\n\nÉ só lembrar o que eu disse no episódio anterior que qualquer matéria é resultado da combinação dos átomos. E que a matéria é descontínua, ou seja, nós vemos corpos macroscópicos que são a junção de corpos microscópicos. Esse fluxo da natureza precisa ser levado pro seu app e pro seu time. Sempre!\n\nNão pense você que quando eu falo desse fluxo 'AUTOMÁGICO' e 'BALA DE PRATA' estou dispensando o designer de Interação, assim como também não devemos eliminar a necessidade de desenhar uma página inteira. É importante que seja formada uma equipe multidisciplinar (UX, UI, Fronts, Backs, Analistas, Engenheiros, etc.) e que cada um consiga dar o seu melhor em cada componente.\n\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2017-12-15T00:00:00",
            "titulo": {
                "resumido": "Sobre views...",
                "completo": "Se você está tratando componente como view, pare agora mesmo."
            },
            "subtitulo": "Atomic Design",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep3-atomic-design-componente-nao-e-view.mp3",
            "duracao": "11:16",
            "texto": "Oi!\nEste é o terceiro episódio de um podcast sobre programação que continua em construção. Se você tem me acompanhado aqui pelo navegador, já pode ver algumas melhorias que tenho feito com base no feedback de todo mundo. Alías, feedback é uma coisa que não me tem faltado! E eu agradeço demais a todo mundo que tem perdido um tempinho pra vir conversar comigo me dando dicas de como melhorar e onde postar os novos episódios. Esse espaço é nosso!\n\nEste é o ELEMENCAST e eu, Luigui Delyer, tenho trazido alguns drops de conteúdo toda semana. O objetivo aqui é aprender ainda mais sobre programação, front-end, javascript, css, html5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional e uma vida como programador organizada em elementos…\n\nO tema de hoje vem pra completar a série sobre Atomic Design que tá rolando desde que eu comecei esse podcast. A forma de separar nosso projeto em componentes me agrada demais e como eu tenho dito, essa metodologia de projeto, pra mim, é a que mais se encaixa no mundo dos componentes.\n\nComponentizar o front é garantir que nosso usuário terá um UI uniforme e um UX previsível. É garantir também que nós possamos reusar diversas partes do nosso código em lugares inimagináveis. Porém, um dos erros mais clássicos cometidos pelos front’s desesperados em entrar nessa onda de React, Vue ou Angular e participar desse movimento de componentes é pensar que agora, ao invés de criarmos páginas, cada componente pode ser uma ‘view’.\n\nDurante os últimos dias eu tenho ajudado algumas pessoas nos canais de telegram que eu participo e se você quiser participar também, eu disponibilizei alguns links aqui no site do podcast na área de mais informações deste episódio, é só clicar no grupo que você quiser pra começar a interagir com centenas de outros programadores brasileiros, eu super indico.\n\nUm dos problemas que eu vejo constantemente é que a cada novo componente criado, a pessoa que está programando o app pensa que está criando uma nova ‘página’ e que pra isso, precisa criar uma nova rota rota se não ela não conseguirá ver esse componente na tela. Gente, não é isso.\n\nNós precisamos entender que COMPONENTE NÃO É VIEW. Mas como assim então, não é view?\n\nVamos falar de teoria rapidinho.\n\nNa definição de Philippe Kruchten, Professor de Engenharia de Software na Universidade de Colúmbia no Canadá, um componente é um elemento independente que pode ser substituído, contudo, é significativo, pois tem uma função clara no contexto em que foi definido.\n\nA Engenharia de Software Baseada em Componentes tem ênfase na decomposição de sistemas, construindo assim, componentes funcionais e lógicos com interfaces bem definidas, usadas para comunicação entre os próprios componentes.\n\nO Desenvolvimento Baseado em Componentes, é uma metodologia que aborda a criação de sistemas de software que envolva a composição de componentes permitindo a adição, adaptação, remoção e substituição de partes do sistema sem a necessidade de sua completa remodelação.\n\nIsso auxilia na manutenção dos sistemas uma vez que, permite a integração de novos componentes e/ou a atualização dos já existentes. A abordagem é criar ou adaptar os componentes para que sejam utilizados em diversos sistemas. Essa idéia vem ao encontro da reutilização que busca flexibilizar o desenvolvimento.\n\nComponentes são considerados como algo que está num nível de abstração mais alto que do que um Objeto, ou até mesmo, no nosso cenário do front, um componente é uma abstração da ‘view’.\nOu seja, se você constrói uma tela inteira por componente, ou até, se você só tem algumas partes separadas em componentes, eu preciso te dizer que você está fazendo isso errado. Não é porque funciona que está certo.\n\nImagina uma ‘unidade’ independente, tipo um container, que pode ser utilizado ao lado ou até mesmo dentro de outros containers e que é capaz de formar containers mais complexos ainda. Ele pode ser um pacote de software, um web service, um recurso específico ou até mesmo um módulo externo que contém diversas funções ou dados.\n\n\n\nSistemas que são construídos de forma separada ou decomposta, ou seja, em componentes, possuem dados e funções dentro de cada um deles que são semanticamente relacionadas. Por causa desse princípio, eles são naturalmente modulares e coesos.\nEles implementam de forma clara interfaces para comunicação, tendo sempre como princípio a criação e utilização de INPUTS EXPLÍCITOS e OUTPUTS EXPLÍCITOS, pois será através dessas interfaces, que acontecerá o tráfego dos dados dentro do seu software.\nEssa forma de comunicação por interfaces leva o nome de composição.\n\nUm componente bem definido, pode muito bem realizar tarefas em diversas partes do seu app e não só em uma parte específica. Trazendo isso pro front, um componente de busca, poderia aprender em diversos contexto separados, onde ele faria a uma pesquisa para o usuário, sem que a pessoa que está programando, precisasse refazer N vezes o mesmo formulário de buscas.\nO modelo de componentes permite o encapsulamento e a interoperabilidade de elementos HTML e Javascript, por exemplo.\n\nUm formulário de cadastro, poderia muito bem servir pra adicionar e editar valores, você não precisa de duas telas pra isso. Nem de duas rotas.\nDentro desse formulário, diversos outros componentes como por exemplo, o de seleção, o de data, o de hora e o componente de upload de fotos. Todos eles funcionando de forma individual e coletiva, ao mesmo tempo.\n\nIsso acontece muito também com grids… O famoso problema das grids… Quem aí é obrigado a utilizar essa maneira de exibir dados, sofre as vezes em ter que manter diversas delas e por mais que muitas vezes nós possamos utilizar algum componente externo que nos ajude a manipular grids, nem sempre nós usamos ele da melhor maneira.\nNo caso das grids, o ideal é sempre ter o seu próprio componente a nível de lógica, que chama o seu componente de grid que cuida do layout e que um fale com o outro, montando definitivamente a grid na tela do usuário.\nA componentização começa ficar mais legal ainda, toda vez que você for manipular dados dessa grid. Por exemplo, você poderia se beneficiar de algum outro componente que é responsável só por iterar arrays.\nLembre-se, nem todo componente precisa ter layout! Ele pode ser só um conjunto de funções e mesmo assim, continuar sendo um componente válido. No Atomic Design, esse cara seria um BÓSON, já que ele não representa nada ‘paupável’, nenhuma matéria em si.\n\nLembra do que eu venho dizendo sobre escopo mínimo? Esse é um exemplo claro disso. Pequenas pecinhas falando entre si, fazendo pequenas coisas pra gerar coisas grandes.\n\nPara nós que queremos viver dentro do Atomic Design, isso é natural, pois nós sempre estamos olhando da menor parte para a maior parte e aí, sempre estamos reusando pedaços do nosso app.\n\nMas quando pensamos nessas interfaces que o componente pode ter, milhares de outras dúvidas nascem.\nVocê pode ter se perguntado: ‘como assim, interface?’\nBom, um componente pode ter simplesmente uma prop ou um atributo que recebe um valor a ser renderizado na tela do usuário e que isso seria sua ‘assinatura’. Pensa num componente como se fosse um função que recebe parâmetros e retorna um novo valor manipulado.\nOutra interface bem comum pode ser a nossa máquina imutável de estados. O componente pode estar ligado num ‘getter’, ou um ‘observer’ do Redux, do Vuex ou do NgRX, e por sua vez, estar ligado também com uma action que terá a função de disparar mutations com novos valores pro estado.\n\nE com isso, nossa aplicação em si, não precisa saber o que acontece lá dentro desse componente, pois ele tem seu próprio lifecycle independente.\nImagina que um componente leva a sério aquele slogan de Las Vegas: O que acontece no componente, fica no componente. A aplicação só fará proveito do dado que o componente manipula e não de como ele faz isso.\n\nOutro importante ponto dos componentes é que eles precisam ser substituíveis! Ou seja, sempre que você fizer um update nesse componente, se você não mudar sua interface de comunicação, claro, você não precisará mudar sua aplicação toda. Ou até, se amanhã você quiser remover esse componente do seu código, sua aplicação não morrerá.\nSeu componente precisa ter a possibilidade de ser substituído em tempo de execução ou em tempo de projeto, sempre! Com isso, você poderá ter ‘mini produtinhos’ vivendo de forma independente dentro do seu software!\n\nJá pensou que legal poder implementar novas funcionalidades aos poucos sem provocar efeitos colaterais na sua aplicação? Você poderia aprender mais sobre a UX em cada pedacinho ou até, testar novos templates e assim sucessivamente.\n\nQualquer sistema de software pode ser formado inteiramente somente por componentes ou não. Isso vai da escolha que você fizer pra arquitetura do seu app. O benefício maior é sempre o reúso absoluto de código em curto e longo prazo.\n\nSe você acha que nesse momento é mais fácil pra você construir uma página nova a cada componente, tudo bem, não sou eu quem vai te forçar a mudar a forma com que você está usando componentes no front, você só precisa entender que pensar numa forma de abstrair seu layout, garante que você trabalhe menos.\n\nEu já presenciei alguns apps lotados de rotas renderizando componentes como se fossem ‘views’. Quando nós usávamos o padrão MVC no front, essa era uma realidade total. Ou até, quando estamos acostumados com ambientes tipo PHP, isso é meio comum pra gente. Nós pensamos logo de cara, que cada rota, tem um visual diferente e que pra isso, precisamos programar esse visual.\nNo mundo do Javascript componentizado, essa não é uma realidade. Quando pensamos em Atomic Design e componentes em Vue, React ou Angular, precisamos estar cientes que estamos construindo sempre um pedacinho que chamará outro pedacinho.\n\nMas você deve ter se perguntado: ‘tá, e pra que serve a rota então?’\n\n\n\nTrazendo as rotas pra dentro do Atomic Design, suas rotas chamarão componentes do tipo PÁGINA ou do tipo TEMPLATE e eles por sua vez, chamarão as moléculas, os organismos e os átomos. Percebe que eu tô falando de forma genérica aqui, então pode ser que um mesmo ÁTOMO pode aparecer em todas as rotas, ou até que o organismo de navegação estará em todos eles. Quem orquestrará todos as interfaces dos componentes que virão na sequencia é sempre o componente mais alto e assim, o fluxo se dará de ‘cima pra baixo’, do componente do tipo PÁGINA até o ÁTOMO.\n\nA reatividade natural dos componentes se dará por conta de outros eventos dentro da sua rota e eles em si, saberão como mudar a tela. Você não precisa por exemplo, criar uma rota pra cara momento do seu CRUD. A cada interação do usuário dentro dele, você pode tomar atitudes com os componentes, independe da rota que a aplicação está. Inclusive, se você não quiser nem usar rotas, você não precisa. Dá pra fazer tudo sem rotas, juro!\nNão precisa ser o maníaco das rotas. Se desprenda delas e promova mais reatividade com os seus componentes. Comece a otimizar suas rotas hoje mesmo!\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu quero continuar instigando sua curiosidade pra que você me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este. Você também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player. Vem trocar ideia!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2018-03-01T00:00:00",
            "titulo": {
                "resumido": "Máquina de estado",
                "completo": "Gerência de estado, Reatividade e Programação funcional - Parte 1"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep4-maquina-de-estados.mp3",
            "duracao": "14:36",
            "texto": "Oi!\nEste é o quarto episódio de um podcast sobre programação que não consegue sair do processo de construção.\n\nEste é o ELEMENCAST e eu, Luigui Delyer, tenho trazido alguns drops de conteúdos legais sobre programação, Front-end, Javascript, CSS, HTML5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional entre outras coisas maneiras.\n\nPra quem me deu diversos feedbacks sobre escutar o podcast pelo navegador do celular, eu sei que ainda não fiz a versão responsiva, paciência tá quase! Uma coisa de cada vez. Se você está no celular e quer um pouco mais de controle sobre o áudio, eu te indico que você use algum App desses especializados em podcasts, eu cadastrei todo conteúdo em todos os Apps que encontrei e se por acaso você não conseguir ouvir no seu App favorito, me dá um toque! Você também pode assinar o Feed RSS que tem na capa do site pra sempre ficar por dentro dos novos conteúdos que eu coloco por aqui, além de sempre ter a possibilidade de baixar o MP3 do episódio pra ouvir quando quiser.\n\nEu preciso agradecer também a todos que me apoiaram e me cobraram novos conteúdos aqui, a vontade de vocês me incentiva a continuar.\n\nNo primeiro, segundo e terceiro episódio, eu falei sobre uma metodologia diferente, o Atomic Design! E se você perdeu algum episódio, é só dar uma conferida, vale a pena.\n\nEssa é a primeira parte de um assunto que foi separado em três partes: Gerência de estados, reatividade e programação funcional no front.\n\nAssim como eu sempre faço um paralelo com a ciência da matéria no Atomic Design, esses termos aí também podem ser paralelizados com o fato de que nós, seres humanos, muitas vezes reagimos de maneiras diferentes conforme os estímulos que recebemos. Nós somos orientados a eventos e por muitas vezes, diante de muitas situações os afetos provocados pelo ambiente onde estamos, alteram nosso estado emocional.\n\nGerência de estados tem sido um assunto da atualidade, principalmente se você está envolvido com Javascript e toda velocidade do nosso ecossistema gigantesco, com certeza, pelo menos já se deparou com algo sobre.\n\nEsse será o primeiro tópico a ser abordado hoje. Se você ainda não sabe o que é uma máquina de estado ou mesmo se sabe mas ainda não tem usado, chegou a hora de começar a admitir que terá que usar. E já te adianto, é um caminho sem volta.\n\nEm Javascript nós possuímos algumas implementações famosas que gerenciam estados.\nA que eu acredito ser a mais conhecida, é a Redux, que se define como uma máquina de estados previsíveis para aplicativos JavaScript. O objetivo dela é te ajudar a escrever aplicações que se comportam de forma consistente, funcionam em diferentes ambientes de desenvolvimento, como clientes, servidores e ambientes nativos que são fáceis de serem testadas. Você pode usar o Redux diretamente com React ou de forma agnóstica em qualquer aplicação JS. O Redux possui uma extensão para o DevTools do Firefox e do Chorme que te permite 'viajar no tempo', ou seja, ir pra frente e pra trás nas ações que o usuário fez enquanto usava a aplicação. E isso é super maneiro, além de ser muito útil.\n\nOutra implementação conhecida atualmente é exclusiva para VueJS, a Vuex. Na minha própria concepção, como Vuex é preso e dependente direto de VueJS, a biblioteca pode se tornar mais poderosa e mais completa que Redux por diversos fatores. Ela se define como um padrão de gerenciamento de estados que serve como um centralizador das informações para todos os componentes. Suas regras internas garantem que o estado da aplicação só possa ser mudado de forma previsível. Assim como Redux, Vuex possui uma extensão para o DevTools do Firefox e do Chorme. Além de você 'viajar no tempo' da aplicação, você pode exportar e importar estados prévios. Acredite, isso ajuda MUITO durante o debug e no tempo de desenvolvimento de uma grande aplicação. Imagina só que você pode reproduzir uma série de ações do usuário até encontrar um determinado bug, ou que até, não precisa ficar fazendo X interações com a aplicação a cada refresh do navegador.\n\nA terceira mais famosa implementação de gerência de estados (e a mais recente) é a ngRX (que é a junção do Redux com RxJS) e é exclusiva para Angular. A biblioteca elenca suas qualidades começando pelo fato de que o estado é uma estrutura de dados única e imutável, que as ações definem as mudanças no estado, e que as funções responsáveis pelas alterações no estado são puras. Como por baixo do capô dela nós temos o Redux, quem já está acostumado com ela e está trabalhando com Angular, não terá problema algum em usar a biblioteca. Da mesma maneira, você poderá usar a extensão do Redux para o DevTools dos navegadores.\n\nA proposta de todas essas bibliotecas é sempre a mesma. Acho que isso ficou bem claro nas suas definições. Todas elas querem te ajudar a gerenciar o estado da aplicação de forma consistente, pura, funcional, imutável e consequentemente, promover a tal reatividade entre seus componentes. Ou seja, esses caras pegam a responsabilidade das informações de todos os seus componentes e te força a descolar uns dos outros, criando diversos gatilhos para que os dados do seu componente possam ir de um lado para o outro de uma forma única, imutável e direcional.\n\nTá, mas aí você pode me dizer que até hoje fez suas aplicações com React, Vue ou Angular sem usar nada disso e que todas funcionam muito bem, obrigado. Ok, realmente não posso discordar de você, todas realmente devem funcionar. Gerência de estado não é bala de prata, mas nada é. Porque então devemos usar uma máquina de estado, ou melhor, quando devemos usar?\n\nO primeiro sinal que você precisa identificar é a quantidade de componentes que você tem na sua aplicação, é um número grande? Se você já caiu de cabeça no Atomic Design, nós sabemos que sim, você terá vários componentes. Talvez até um número que nós dois tenhamos vergonha de falar por aí porque pode parecer loucura.\nOutro sinal é a 'árvore genealógica' que seus componentes formam, por exemplo, quando você tem um componente pai que chama um componente filho, que reage num componente neto e que a interação do usuário provocará uma reação no componente tio! Bizarro isso, né?\nOu até se mesmo assim você conseguir disparar esses eventos todos chamando de trás pra frente o fluxo dos dados, você consegue imaginar a panela de espaguete que está construindo? Esse App, com certeza vai trazer dores algum dia que você precisar desmontar esse castelo de cartas aí.\n\nOutro ponto importante que você precisa pensar é se o seu fluxo de dados está preso a sua interface, a partir do momento que as informações que você tem, são somente as que estão renderizadas na tela, você precisará se esforçar muito mais pra fazer que as informações fluam para que assim novas telas apareçam. Da mesma maneira, se seu estado estiver distribuído somente na sua interface nos componentes já renderizados, a qualquer mudança desse estado, você terá de 'inundar' todos os componentes com as alterações para que sua informação chegue no destinatário correto.\n\nÉ como aqueles hub's de rede antigos, lembra? (Se você nasceu em 90, e conseguiu acompanhar o começo da internet, com certeza você sabe do que eu tô falando). Esses hub's simplesmente não sabiam quem eram os computadores ligados a eles e então, eles simplesmente 'inundavam' a rede toda e todas as máquinas atrás do destinatário. Consegue imaginar a latência e a lentidão que isso provocava? Pois é, isso acontece nesse seu App gigante aí que ainda não tem gerência de estado isolada dos componentes.\n\nQuando você não tem ninguém que está por fora dos seus componentes gerenciando os dados, você também é obrigado a passar diversas vezes um mesmo valor pelas propriedades do componente até que ele chegue no seu destinatário. Com esse cenário completo, fica evidente que 'debugar' esse aplicativo será um inferno.\n\nSe por acaso, o App que você está trabalhando agora não faz parte de nenhum desses cenários, então definitivamente você não precisa usar uma máquina de estados.\n\nUm dos pontos que eu acho importante ressaltar, é que máquinas de estado são verbosas e se você é daqueles programadores que odeiam burocracia, nem tente, você vai odiar esse ponto. Porém, se você é aquele tipo de programador que quer performance, interoperabilidade, escalabilidade, consistência e clareza no seu código, você vai amar trabalhar com uma máquina de estado finito.\n\nE como funciona o fluxo de dados dentro dessas coisas? Como fica a parte prática disso? Bom, como eu exemplifiquei somente Redux e Vuex, vou te contar como funcionam estas bibliotecas, o que claramente não resume todas as implementações disponíveis.\n\nNo Redux, a regência do estado fica separada em 3 camadas, no Vuex em 4. Eu vou tentar fazer um paralelo entre os dois e explicar as diferenças de cada uma delas, então se liga só:\n - O centralizador das informações, onde todos os dados da aplicação estão ali disponíveis para todos os componentes, no Redux chamamos de Store, no Vuex chamamos de State.\n - As funções puras que tem a capacidade e autoridade de alterar o estado da aplicação são os Reducers no Redux e as Mutations no Vuex. Essas funções são responsáveis por receberem os valores da sua aplicação, modificarem o estado e registrarem um estado completamente novo na memória.\n - Os invocadores das funções que alteram o estado são chamados de Actions nas duas bibliotecas. Porém, elas possuem uma diferença em cada uma delas. No Vuex elas são naturalmente assíncronas e devem ser responsáveis pelas requisições externas nas API´s que você estiver utilizando. No Redux é quase a mesma coisa, porém a diferença fica na implementação do código em si. Você precisa fazer algumas etapas a mais pra deixar sua Action assíncrona. Vale lembrar que é super importante que seus Ajax estejam sempre dentro da máquina de estados. Ela deve ser responsável pode solicitar, receber, tratar e armazenar os dados e não os seus componentes.\n - Entre as duas bibliotecas existem uma diferença gigantesca e que pra mim faz todo sentido. No Vuex nós temos uma camada a mais que são os Getters. Esses caras são funções puras, assim como as Mutations, porém, elas tem uma função contrária. Elas são responsáveis por processar a retornar um pedaço do estado. Ou seja, com um Getter você consegue apontar pra pedaços isolados do estado de dentro do seu componente sem precisar se preocupar com a validação do dado. Essas validações acontece Getter em si. No VueJS, o Getter é o cara responsável por promover a reatividade perfeita no componente.\n\nTendo isso tudo em mente, já dá pra ter uma ideia, de que em qualquer momento, qualquer componente pode invocar uma situação da máquina de estados e que ela por sua vez terá o papel de centralizadora da verdade. Tudo que passa por ela e está nela, é certamente confiável e consistente.\n\nVocê começará a perceber que assim, seus componentes se tornam ainda mais independentes, funcionais e puros. A qualquer momento você pode simplesmente substituir qualquer componente pois a lógica dos dados está dentro do estado da aplicação e não mais no componente. Ele servirá apenas pra renderizar o layout na tela e receber as interações do usuário.\n\nTrazendo para o nosso cenário do Atomic Design, isso se encaixa perfeito pelo fato de termos milhares de componentes pequenos, falando a mesma língua de forma independente e coesa.\n\nA reatividade provocada de forma natural pela máquina de estado será o nosso próximo tema. Vou aprofundar ainda mais no assunto para exemplificar o fluxo do estado atualizando nossa View de forma uniforme e direcional.\n\nEu gostaria de frisar que tentei, de verdade, desconectar programação reativa de programação funcional. Do mesmo jeito que tento desconectar componentização real de Atomic Design e não consigo. Se você não gosta desses termos ou ainda não sacou que o próximo hype do front são justamente esses, eu preciso te dizer que tá na hora de aceitar a onda e cair nela, pra não cair de cima dela.\n\nVocê sabe tão bem quanto eu que nós programadores de Front-End, vivemos de hype. Hypes pra todo lado! E em 2018 será a vez de mergulharmos de cabeça em reatividade, controle de estados e programação funcional. É só vermos que GraphQL tem se tornado o novo padrão de comunicação entre front e back e que algumas outras ferramentas de tipagem como Flow e Typescrpit tem ganhado força em tão pouco tempo. Da mesma maneira temos Elm e ReasonML levando o front pro mundo funcional com força. Precisamos estar atentos a todas essas coisas novas que estão acontecendo no mercado. Jajá essas coisas serão requisitos em vagas.\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu quero continuar instigando sua curiosidade pra que você me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter do podcast, eu sempre aviso quem tá lá primeiro quando sai um novo episódio e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida se coloca uma máquina de estado naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este. Você também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player no site.\n\nVem trocar ideia!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        }
    ]
}
