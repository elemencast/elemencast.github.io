{
    "episodios": [
        {
            "data": "2017-11-30T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Lançamento do podcast! Você já ouviu sobre Atomic Design?"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep1-atomic-design.mp3",
            "duracao": "08:41",
            "descricao": "Neste primeiro episódio eu irei explanar superficialmente os conceitos básicos de Atomic Design, mas pra isso, precisamos de teoria e vamos voltar um pouco nos tempos da escola pra falarmos sobre um assunto muito antigo mas completamente atual. Segundo a Wikipédia, em física e química, modelo atômico é todo modelo científico que se usa para explicar os átomos e seus comportamentos. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\n\nEste é o primeiro episódio de um podcast sobre programação que está em construção.\nSe você estiver ouvindo pelo browser, pode perceber o que eu estou dizendo só de olhar para a página onde está o player.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo de no máximo 10 minutos toda semana. O objetivo aqui é aprender ainda mais sobre programação.\nFalaremos sobre front-end, javascript, css, html5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional e uma vida como programador organizada em elementos...\nEu inicío esse podcast hoje já falando de um tema que tenho gostado muito e gostaria de compartilhar com você como tem sido desenvolver no front de forma atômica e pra isso, precisamos começar falando diretamente sobre uma metodologia de projeto que me agrada muito, o Atomic Design.\nSe você nunca ouviu falar sobre isso, eu te digo de uma forma simples rápida:\n\nAtomic Design nada mais é do que uma forma de desenhar projetos.\nSeja na documentação, no layout, na forma com que criamos os testes, como separamos os arquivos, como pensamos nas funcionalidades do programa, na forma com que vamos reusar o código, entre outros.\nExistem diversas outras formas de fazer isso, algumas bem conhecidas são DDD e SOLID. Você pode ter lembrado do famoso MVC também, porém, ele não entra nesse caso já que o padrão MVC não é um design pattern propriamente dito.\nEu escolhi Atomic Design porque me deparei com o fato de que eu consigo levar essa maneira de pensar pra quase qualquer coisa que esteja relacionada a forma com que eu programo algo.\n\nDurante os próximo episódios nós conversaremos a fundo sobre como funciona isso e teremos uma série especializada no tema. Descobriremos qual tecnologia usar e como  chegar na conclusão de que nosso software precisa ser componentizado, atômico e reativo.\nNas próximas semanas também, eu terei aqui comigo, alguns amigos que nos ajudarão a entender ainda mais alguns dos temas que eu citei logo no início.\nNeste primeiro episódio eu irei explanar superficialmente os conceitos básicos de Atomic Design, mas pra isso, precisamos de teoria e vamos voltar um pouco nos tempos da escola pra falarmos sobre um assunto muito antigo mas completamente atual.\n\nSegundo a Wikipédia, em física e química, modelo atômico é todo modelo científico que se usa para explicar os átomos e seus comportamentos.\nNo século V antes de Cristo, alguns filósofos defendiam o atomismo, pois acreditavam que dividindo a matéria em pedaços cada vez menores, seria possível encontrar partículas que seriam invisíveis ao olho humano e, segundo esses pensadores, os átomos filosóficos vêm em uma variedade infinita de formas e tamanhos cada uma delas sendo indestrutíveis, imutáveis e cercadas por um vazio onde colidem com outras partículas ou se reúnem em algo que hoje chamamos de moléculas, organismos e matéria.\n\nPartindo desse princípio, nasceu a proposta de que o todo, se compõe não só de átomos ou partículas indivisíveis de natureza idêntica. Aí então nasceu a teoria da unidade e imutabilidade do ser.\nAcredita-se que vácuo e matéria desde a eternidade interagem entre si dando origem ao movimento, e que os átomos apresentam as propriedades de: forma, movimento, tamanho e impenetrabilidade, e, por meio de choques entre si, dão origem a objetos.\nUm desses filósofos, defendia que a matéria era descontínua, portanto, ao invés dos corpos macroscópicos que nós vemos, os corpos microscópicos ou os átomos não podem ocupar o mesmo espaço no tempo nem podem ser divididos, sendo suas mudanças observadas em fenômenos físicos e químicos como por exemplo a junção ou separação dos átomos e que qualquer matéria é resultado da combinação dos átomos dos quatro elementos básicos: ar; fogo; água e terra.\n\nTá, e o que programação tem a ver com nisso?\n\nO criador do Atomic Design, Brad Frost, desenhou cinco camadas básicas de divisão unindo todo esse conceito aí que você ouviu agora. No pensamento dele, nosso software pode ser separado por ÁTOMOS, MOLÉCULAS, ORGANISMOS, TEMPLATES e PÁGINAS.\nE há pouco tempo atrás, estudando mais sobre a metodologia, eu encontrei lugar para mais dois elementos os BÓSONS e os QUARKS.\nEu vou explicar um por um, relaxa.\n\nÁTOMO\nUm elementos mínimo presente em uma interface gráfica.\nNo mundo dos componentes eles são labels, inputs, campos de formulário, botões, títulos, parágrafos, etc.\n\nMOLÉCULA\nSão dois ou mais átomos mantidos juntos para funcionarem com um propósito único.\nUma molécula seria então um input junto com um botão que juntos, tem a função de busca numa interface gráfica.\n\nORGANISMOS\nNaturalmente, são duas ou mais moléculas que começam a moldar a navegação e a leitura do conteúdo nessa interface.\nAumentando o exemplo, a molécula de busca ao lado da molécula de navegação e do logotipo, faz parte do organismo header.\n\nTEMPLATES\nBom, você já deve ter entendido que estamos falando cada vez mais sobre abstrações da interface, né? Os templates consistem em vários organismos combinados para formar páginas.\n\nPÁGINAS\nE as páginas são uma evolução natural dos templates. Ou seja, são os layouts em si.\nLembra que eu disse que encontrei o caso de uso pra mais dois elementos?\n\nBÓSONS\nSão aquelas “coisinhas” que fazem uma grande diferença no visual e legibilidade de uma interface. Eles não precisam ser literalmente visíveis, pois são abstratos, como paletas de cores, fontes, animações e aspectos ainda mais invisíveis de uma interface como grids.\n\nQUARKS\nUm cara desses nunca é encontrado isoladamente, isto significa que um Quark só existirá quando existir um elemento completo.\nComo por exemplo, itens que enviam feedback para o usuário, como barras de progresso ou rolagem, validações em formulário, hints, dicas, tips de ajuda e etc...\n\nOu seja, imagina agora que tudo isso junto na mesma página tem uma vida própria, um escopo muito reduzido e uma capacidade natural de interagir entre si. Como cada item desse é um componente vivendo no seu app, você precisa ter um orquestrador, digamos assim, e é aí que entra o conceito de controle de estados imutáveis e reatividade entre todos os componentes... \n\nAfinal, quando você clicar no átomo de botão que está dentro da molécula de busca, o organismo de conteúdo precisará ser atualizado dentro do template de pesquisa para renderizar a página com o resultado...\n\nTá... Acho que agora você deve estar pensando em que é coisa pra caramba pra controlar e que é muito difícil abstrair tudo e começar a pensar assim... Bom... Eu preciso te dizer que não, é bem pelo contrário... Imagina que como eu disse agora pouco, o mundo funciona assim, a natureza rege tudo dessa maneira, então cabe a nós darmos continuidade na forma natural da vida dentro do nosso mundo digital.\nQuando você fizer isso, vai começar a perceber e será natural a aplicação de vários conceitos de programação funcional (que falaremos em breve), funções puras, códigos explícitos, escopos mínimos, reatividade natural, componentização obrigatória e também da coisa mais desejada de todos os programadores e gestores de TI... \n\nREÚSO DE CÓDIGO DE VERDADE!\n\nEu te garanto que a partir do momento que você decidir usar Atomic Design no seu dia a dia como programador, sua produtividade aumentará absurdamente.\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\nUma comunidade forte, é uma comunidade unida que se ajuda.\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2017-12-07T00:00:00",
            "titulo": {
                "resumido": "Atomic Design",
                "completo": "Tá, quero separar tudo em componentes! Como ficam os entregáveis? Os arquivos mesmo..."
            },
            "subtitulo": "Parte 2",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep2-atomic-design.mp3",
            "duracao": "12:12",
            "descricao": "No primeiro episódio, eu falei de uma forma bem básica e suave o conceito principal do Atomic Design. Hoje, eu vou aprofundar um pouco mais, tratando a forma que ficam os entregáveis, como é a interação do time durante o desenvolvimento do sistema e qual é o papel de cada um no processo de criação do app, também vou falar um pouquinho mais de programação funcional também, afinal pra mim, Atomic Design e programação funcional, são almas gêmeas. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\n\nEste é o segundo episódio de um podcast sobre programação que continua em construção.\nEste é o ELEMENCAST e eu, Luigui Delyer, tentarei trazer alguns drops de conteúdo toda semana.\nAntes de começar hoje, eu preciso agradecer muito a cada um que parou o que estava fazendo pra me ouvir e interagir comigo nos últimos dias... Foram inúmeros feedbacks positivos e foi surpreendente ver a quantidade de pessoas que se interessaram pelo assunto! Fico feliz em saber que vamos trilhar um caminho legal pela frente. Então já sabe, vem trocar ideia comigo em alguma das minhas redes sociais que estão no site do ELEMENCAST.\nUm dos feedbacks que eu recebi é que só dei exemplos de uso do Atomic Design em interfaces gráficas e aí o pessoal que manda bem em NodeJS e outras soluções pra backend e que não é muito feliz com CSS e design, ficou meio sem ver o valor que a metodologia poderia ter no back. Eu preciso dizer que sim, Atomic Design pode ter um lugar aí no seu coraçãozinho sem layout no back também.\n\nNo primeiro episódio, eu falei de uma forma bem básica e suave o conceito principal do Atomic Design. Hoje, eu vou aprofundar um pouco mais, tratando a forma que ficam os entregáveis, como é a interação do time durante o desenvolvimento do sistema e qual é o papel de cada um no processo de criação do app, também vou falar um pouquinho mais de programação funcional também, afinal pra mim, Atomic Design e programação funcional, são almas gêmeas.\nO lance principal é que a metodologia pretende te forçar a pensar em abstração de código e te fazer olhar sempre pra menor parte do app e ir 'subindo'...\n\nSe você está construindo uma API Rest em NodeJS com Express por exemplo, você pode pensar que sua rota tem uma função e essa função é uma página (lembre-se que página aqui não é literalmente uma que poderá ser renderizada por sua rota e sim o elemento de abstração mais alto do Atomic Design a função em si).\nAgora pense que essa função só tem uma obrigação, chamar as outras funções que constroem o 'template' passando os parâmetros da rota. Só aqui, já começamos a ter funções puras e modularização natural. O template seria o conteúdo principal, uma espécie de core da sua rota e dentro dele, nós chamaremos as funções 'menores' digamos assim passando mais parâmetros, até chegar naquela sua função que tem o único propósito de devolver um array filtrado de dados, por exemplo.\n\nPercebe que só de termos chegado nessa função minúscula de filtrar um array, já nos deparamos com uma situação que nos fará escrever um código com mais qualidade e que isso será completamente natural e involuntário... Uma função que filtra um array é automaticamente reusável. É uma função pura que tem um escopo muito reduzido, um input explícito (que seria o nosso array bruto) e um output explícito (que será o array filtrado).\n\nParece até chato ficar repetindo isso de função pura e etc, mas é que eu realmente quero que isso fique fixado na sua mente e que você não pare de pensar nisso. Assim que você ver o seu código, quero que você fique com vontade de refatorar aquela função gigante que você escreveu ontem e que manipula 10 objetos globais...\nEsse inclusive é aquele momento ótimo pra você aprender a não usar mais for's e while's... Sim, essa vida de loops não te pertence mais... Nós podemos fazer 99,99% de todos os loops de dados usando as três funções principais de iteração map, filter e reduce.\nVocê já deve ter visto essas três palavrinhas em algum lugar da web que falava de ES6 ou das novidades de Javascript...\nTem muito artigo bom na internet sobre isso e eu recomendo fortemente o artigo do Vinicius Reis que tem o título: “Reduce, mais um dia sem loops.”. Você pode encontrar esse artigo facilmente lá no Medium ou usando seu buscador favorito. Em breve, eu abordarei cada um desses temas aí, assim, aprenderemos como é isso de viver sem loops.\n\nVocê só não pode esquecer de fazer uma função genérica com inputs e outputs definidos e com isso automaticamente você estará fazendo um código reusável e que não gera efeitos colaterais em outras partes do seu app.\n\nEFEITOS COLATERAIS? COMASSIM?\n\nToda função que não é pura, ou seja, que manipula um valor dentro dela que não foi passado por um parâmetro, está alterando um pedaço fora do escopo dela mesmo. Ou seja, está provocando um efeito colateral em algo que talvez você não queira... Se uma variável global define uma URL e você altera esse endereço dentro da função, todas as outras funções receberão esse valor alterado e isso poderá te gerar um problema sem tamanho... Sem contar que manipular dados assim, tiram qualquer característica de reuso dessa função... Você terá de escrever sempre uma função nova pra fazer coisas diferentes só que fazendo a mesma coisa...\nReuso de código é um desejo de todos! Sempre foi... Escrever menos, produzir mais, produzir melhor, produzir sempre\nE para que essas funções todas sejam reusáveis você precisará modularizar seu código inteiro, então logo nós teremos vários arquivos com poucas linhas de código que serão módulos exportando código pra outros módulos e em algum momento, você terá uma função que passa outra função como parâmetro para receber um valor lá de longe. E toda vez que você fizer isso, estará criando e usando alguns conceitos de programação funcional como High Order Function, First Class Function e Lambda Function. Se você não sabe o que são esses temas, pode ficar sossegado porque em um dos próximos episódios nós abordaremos esse assunto com quem manja de verdade.\n\nEssa forma de programar e pensar em módulos já é uma realidade no front e no back. Se você usa React, Vue, Angular, Mithrill ou qualquer outro framework JS com algum pré-processador de arquivos como Webpack, Rollup, Browserify, Gulp ou Grunt, você sabe do que estou falando.\nA facilidade de importar e exportar códigos e fazer essa conexão entre arquivos não se limita a Javascript, várias outras tecnologias de front também possuem essa capacidade. Por exemplo SASS, Stylus e LESS que são pré-processadores de CSS e a linguagem de templates PUG fazem importação de módulos desde sempre. E particularmente, quem me conhece sabe o quanto eu adoro PUG e SASS.\n\nLembre-se, não é obrigatório seguir o fluxo proposto pelo Atomic Design de 'página > template > organismo > molécula > átomo'. Se você precisar ir de 'página' pra 'átomo' diretamente, tudo bem! Só não esqueça que o fluxo do dado é sempre do menor para o maior e que as chamadas das funções partem sempre das maiores pras menores. Ou seja, você não pode fazer um átomo chamar outro átomo que chama outro átomo, que chama mais um outro átomo... Não faz sentido isso... Você precisa orquestrar essas chamadas.\n\nMas então e esse monte de arquivinhos espalhados na minha pasta SOURCE, e agora? O ATOMIC DESIGN é bem flexível quanto a isso e o que eu vou te falar aqui agora é o jeito que EU faço, é a MINHA preferência pessoal e eu te indico fortemente essa maneira, pois ela é um catado geral de vários projetos que eu já acompanhei sendo criados com a metodologia e a soma da experiência que eu já tive fazendo projetos por onde passei.\nDentro do seu diretório 'source' ('/src'), crie um sub-diretório chamado 'componentes' e dentro dele crie mais alguns sub-diretórios chamados 'atomos', 'moleculas', 'organismos', 'templates' e 'paginas', assim mesmo, no plural. Se você preferir, pode criar em inglês também, lembre-se que essa é uma escolha totalmente sua, o mais importante aqui é saber diferenciar a hierarquia das coisas, o seu código dentro desses diretórios é mais importante do que o nome deles em si. No seu bundle, essas pastas não terão nenhum valor, então foca na funcionalidade!\n\nO conteúdo de cada um desses diretórios poderá ser outros diretórios nomeando os componentes e isso quem controlará será você, seu framework e o seu time. Como por exemplo, se você está desenvolvendo um webapp com VueJS, você 'não precisa' de pastas. Os 'Vue Single File Components' já contém tudo relacionado ao seu componente. Porém, se estiver usando React com SASS ou Angular com HTML e CSS externos, terá de criar uma pasta para cada componente e dentro dela, todos os arquivos relacionados a ele.\nÉ válido lembrar que se você criar diretórios para cada componente o restante do time poderá atuar individualmente em cada um deles, já que a metodologia visa integrar equipes inteiras e agilizar a entrega de protótipos, wireframes e layouts para que todos tenham tempo de focar em partes específicas, estratégicas e na qualidade do código que será entregue ao cliente.\nComo por exemplo, a equipe destinada a documentar o código poderá colocar o arquivo Markdown da documentação do componente dentro da sua respectiva pasta. O designer poderá colocar o arquivo JPG de como deverá ser o layout do componente no final, O Dev que gosta de escrever os testes poderá deixar o arquivo '.spec' dele lá dentro também e assim sucessivamente... Tudo que for relacionado a esse componente deve estar dentro da pasta dele.\nNo lugar de serem entregues inúmeros arquivos em PSD ou JPG pro cliente ficar aprovando e depois os Devs ficarem fatiando e refazendo a cada alteração, você vai conseguir concentrar tudo num repositório de padrões de interações que serão usadas pelo webapp e com as interações já funcionando. Afinal, cada componente tem vida própria, lembra? Eles são independentes e estarão funcionando de forma ordenada, em conjunto com o todo. Mesmo se eles não possuírem lógica, como por exemplo se foram apenas de HTML e CSS você já terá uma noção real de como ficará o app em diversos tamanhos de telas, como serão as animações e etc...\n\nSim, serão muitos arquivos. Esteja preparado pra isso. Tenha em mente o lado positivo da coisa, você terá uma responsabilidade menor de código com cada um deles e acima de tudo está construindo um código escalável tanto no layout quanto em documentação, testes, performance, qualidade e legibilidade de código por estar sempre pensando do menor para o maior e com isso, atingindo todas as áreas.\nParticularmente também, você pode escolher pular alguma dessas etapas, como por exemplo, as vezes eu não crio nenhum componente do tipo 'página'. Dependendo do projeto, os componentes do tipo 'template' são suficientes. Então, se você se deparar com uma necessidade de pular alguma camada mais alta de abstração, fique a vontade. Você só não poderá pular a etapa dos 'átomos', pois ela é a base de tudo. Lembre-se, Atomic Design te fazer olhar de baixo pra cima, do menor pro maior. É importante frisar isso.\n\nÉ só lembrar o que eu disse no episódio anterior que qualquer matéria é resultado da combinação dos átomos. E que a matéria é descontínua, ou seja, nós vemos corpos macroscópicos que são a junção de corpos microscópicos. Esse fluxo da natureza precisa ser levado pro seu app e pro seu time. Sempre!\n\nNão pense você que quando eu falo desse fluxo 'AUTOMÁGICO' e 'BALA DE PRATA' estou dispensando o designer de Interação, assim como também não devemos eliminar a necessidade de desenhar uma página inteira. É importante que seja formada uma equipe multidisciplinar (UX, UI, Fronts, Backs, Analistas, Engenheiros, etc.) e que cada um consiga dar o seu melhor em cada componente.\n\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu queria instigar sua curiosidade pra que você pesquise mais sobre o assunto e me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2017-12-15T00:00:00",
            "titulo": {
                "resumido": "Sobre views...",
                "completo": "Se você está tratando componente como view, pare agora mesmo"
            },
            "subtitulo": "Desabafo",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep3-atomic-design-componente-nao-e-view.mp3",
            "duracao": "11:16",
            "descricao": "urante os últimos dias eu tenho ajudado algumas pessoas nos canais de telegram que eu participo e se você quiser participar também, eu disponibilizei alguns links aqui no site do podcast na área de mais informações deste episódio, é só clicar no grupo que você quiser pra começar a interagir com centenas de outros programadores brasileiros, eu super indico. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\nEste é o terceiro episódio de um podcast sobre programação que continua em construção. Se você tem me acompanhado aqui pelo navegador, já pode ver algumas melhorias que tenho feito com base no feedback de todo mundo. Alías, feedback é uma coisa que não me tem faltado! E eu agradeço demais a todo mundo que tem perdido um tempinho pra vir conversar comigo me dando dicas de como melhorar e onde postar os novos episódios. Esse espaço é nosso!\n\nEste é o ELEMENCAST e eu, Luigui Delyer, tenho trazido alguns drops de conteúdo toda semana. O objetivo aqui é aprender ainda mais sobre programação, front-end, javascript, css, html5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional e uma vida como programador organizada em elementos…\n\nO tema de hoje vem pra completar a série sobre Atomic Design que tá rolando desde que eu comecei esse podcast. A forma de separar nosso projeto em componentes me agrada demais e como eu tenho dito, essa metodologia de projeto, pra mim, é a que mais se encaixa no mundo dos componentes.\n\nComponentizar o front é garantir que nosso usuário terá um UI uniforme e um UX previsível. É garantir também que nós possamos reusar diversas partes do nosso código em lugares inimagináveis. Porém, um dos erros mais clássicos cometidos pelos front’s desesperados em entrar nessa onda de React, Vue ou Angular e participar desse movimento de componentes é pensar que agora, ao invés de criarmos páginas, cada componente pode ser uma ‘view’.\n\nDurante os últimos dias eu tenho ajudado algumas pessoas nos canais de telegram que eu participo e se você quiser participar também, eu disponibilizei alguns links aqui no site do podcast na área de mais informações deste episódio, é só clicar no grupo que você quiser pra começar a interagir com centenas de outros programadores brasileiros, eu super indico.\n\nUm dos problemas que eu vejo constantemente é que a cada novo componente criado, a pessoa que está programando o app pensa que está criando uma nova ‘página’ e que pra isso, precisa criar uma nova rota rota se não ela não conseguirá ver esse componente na tela. Gente, não é isso.\n\nNós precisamos entender que COMPONENTE NÃO É VIEW. Mas como assim então, não é view?\n\nVamos falar de teoria rapidinho.\n\nNa definição de Philippe Kruchten, Professor de Engenharia de Software na Universidade de Colúmbia no Canadá, um componente é um elemento independente que pode ser substituído, contudo, é significativo, pois tem uma função clara no contexto em que foi definido.\n\nA Engenharia de Software Baseada em Componentes tem ênfase na decomposição de sistemas, construindo assim, componentes funcionais e lógicos com interfaces bem definidas, usadas para comunicação entre os próprios componentes.\n\nO Desenvolvimento Baseado em Componentes, é uma metodologia que aborda a criação de sistemas de software que envolva a composição de componentes permitindo a adição, adaptação, remoção e substituição de partes do sistema sem a necessidade de sua completa remodelação.\n\nIsso auxilia na manutenção dos sistemas uma vez que, permite a integração de novos componentes e/ou a atualização dos já existentes. A abordagem é criar ou adaptar os componentes para que sejam utilizados em diversos sistemas. Essa idéia vem ao encontro da reutilização que busca flexibilizar o desenvolvimento.\n\nComponentes são considerados como algo que está num nível de abstração mais alto que do que um Objeto, ou até mesmo, no nosso cenário do front, um componente é uma abstração da ‘view’.\nOu seja, se você constrói uma tela inteira por componente, ou até, se você só tem algumas partes separadas em componentes, eu preciso te dizer que você está fazendo isso errado. Não é porque funciona que está certo.\n\nImagina uma ‘unidade’ independente, tipo um container, que pode ser utilizado ao lado ou até mesmo dentro de outros containers e que é capaz de formar containers mais complexos ainda. Ele pode ser um pacote de software, um web service, um recurso específico ou até mesmo um módulo externo que contém diversas funções ou dados.\n\n\n\nSistemas que são construídos de forma separada ou decomposta, ou seja, em componentes, possuem dados e funções dentro de cada um deles que são semanticamente relacionadas. Por causa desse princípio, eles são naturalmente modulares e coesos.\nEles implementam de forma clara interfaces para comunicação, tendo sempre como princípio a criação e utilização de INPUTS EXPLÍCITOS e OUTPUTS EXPLÍCITOS, pois será através dessas interfaces, que acontecerá o tráfego dos dados dentro do seu software.\nEssa forma de comunicação por interfaces leva o nome de composição.\n\nUm componente bem definido, pode muito bem realizar tarefas em diversas partes do seu app e não só em uma parte específica. Trazendo isso pro front, um componente de busca, poderia aprender em diversos contexto separados, onde ele faria a uma pesquisa para o usuário, sem que a pessoa que está programando, precisasse refazer N vezes o mesmo formulário de buscas.\nO modelo de componentes permite o encapsulamento e a interoperabilidade de elementos HTML e Javascript, por exemplo.\n\nUm formulário de cadastro, poderia muito bem servir pra adicionar e editar valores, você não precisa de duas telas pra isso. Nem de duas rotas.\nDentro desse formulário, diversos outros componentes como por exemplo, o de seleção, o de data, o de hora e o componente de upload de fotos. Todos eles funcionando de forma individual e coletiva, ao mesmo tempo.\n\nIsso acontece muito também com grids… O famoso problema das grids… Quem aí é obrigado a utilizar essa maneira de exibir dados, sofre as vezes em ter que manter diversas delas e por mais que muitas vezes nós possamos utilizar algum componente externo que nos ajude a manipular grids, nem sempre nós usamos ele da melhor maneira.\nNo caso das grids, o ideal é sempre ter o seu próprio componente a nível de lógica, que chama o seu componente de grid que cuida do layout e que um fale com o outro, montando definitivamente a grid na tela do usuário.\nA componentização começa ficar mais legal ainda, toda vez que você for manipular dados dessa grid. Por exemplo, você poderia se beneficiar de algum outro componente que é responsável só por iterar arrays.\nLembre-se, nem todo componente precisa ter layout! Ele pode ser só um conjunto de funções e mesmo assim, continuar sendo um componente válido. No Atomic Design, esse cara seria um BÓSON, já que ele não representa nada ‘paupável’, nenhuma matéria em si.\n\nLembra do que eu venho dizendo sobre escopo mínimo? Esse é um exemplo claro disso. Pequenas pecinhas falando entre si, fazendo pequenas coisas pra gerar coisas grandes.\n\nPara nós que queremos viver dentro do Atomic Design, isso é natural, pois nós sempre estamos olhando da menor parte para a maior parte e aí, sempre estamos reusando pedaços do nosso app.\n\nMas quando pensamos nessas interfaces que o componente pode ter, milhares de outras dúvidas nascem.\nVocê pode ter se perguntado: ‘como assim, interface?’\nBom, um componente pode ter simplesmente uma prop ou um atributo que recebe um valor a ser renderizado na tela do usuário e que isso seria sua ‘assinatura’. Pensa num componente como se fosse um função que recebe parâmetros e retorna um novo valor manipulado.\nOutra interface bem comum pode ser a nossa máquina imutável de estados. O componente pode estar ligado num ‘getter’, ou um ‘observer’ do Redux, do Vuex ou do NgRX, e por sua vez, estar ligado também com uma action que terá a função de disparar mutations com novos valores pro estado.\n\nE com isso, nossa aplicação em si, não precisa saber o que acontece lá dentro desse componente, pois ele tem seu próprio lifecycle independente.\nImagina que um componente leva a sério aquele slogan de Las Vegas: O que acontece no componente, fica no componente. A aplicação só fará proveito do dado que o componente manipula e não de como ele faz isso.\n\nOutro importante ponto dos componentes é que eles precisam ser substituíveis! Ou seja, sempre que você fizer um update nesse componente, se você não mudar sua interface de comunicação, claro, você não precisará mudar sua aplicação toda. Ou até, se amanhã você quiser remover esse componente do seu código, sua aplicação não morrerá.\nSeu componente precisa ter a possibilidade de ser substituído em tempo de execução ou em tempo de projeto, sempre! Com isso, você poderá ter ‘mini produtinhos’ vivendo de forma independente dentro do seu software!\n\nJá pensou que legal poder implementar novas funcionalidades aos poucos sem provocar efeitos colaterais na sua aplicação? Você poderia aprender mais sobre a UX em cada pedacinho ou até, testar novos templates e assim sucessivamente.\n\nQualquer sistema de software pode ser formado inteiramente somente por componentes ou não. Isso vai da escolha que você fizer pra arquitetura do seu app. O benefício maior é sempre o reúso absoluto de código em curto e longo prazo.\n\nSe você acha que nesse momento é mais fácil pra você construir uma página nova a cada componente, tudo bem, não sou eu quem vai te forçar a mudar a forma com que você está usando componentes no front, você só precisa entender que pensar numa forma de abstrair seu layout, garante que você trabalhe menos.\n\nEu já presenciei alguns apps lotados de rotas renderizando componentes como se fossem ‘views’. Quando nós usávamos o padrão MVC no front, essa era uma realidade total. Ou até, quando estamos acostumados com ambientes tipo PHP, isso é meio comum pra gente. Nós pensamos logo de cara, que cada rota, tem um visual diferente e que pra isso, precisamos programar esse visual.\nNo mundo do Javascript componentizado, essa não é uma realidade. Quando pensamos em Atomic Design e componentes em Vue, React ou Angular, precisamos estar cientes que estamos construindo sempre um pedacinho que chamará outro pedacinho.\n\nMas você deve ter se perguntado: ‘tá, e pra que serve a rota então?’\n\n\n\nTrazendo as rotas pra dentro do Atomic Design, suas rotas chamarão componentes do tipo PÁGINA ou do tipo TEMPLATE e eles por sua vez, chamarão as moléculas, os organismos e os átomos. Percebe que eu tô falando de forma genérica aqui, então pode ser que um mesmo ÁTOMO pode aparecer em todas as rotas, ou até que o organismo de navegação estará em todos eles. Quem orquestrará todos as interfaces dos componentes que virão na sequencia é sempre o componente mais alto e assim, o fluxo se dará de ‘cima pra baixo’, do componente do tipo PÁGINA até o ÁTOMO.\n\nA reatividade natural dos componentes se dará por conta de outros eventos dentro da sua rota e eles em si, saberão como mudar a tela. Você não precisa por exemplo, criar uma rota pra cara momento do seu CRUD. A cada interação do usuário dentro dele, você pode tomar atitudes com os componentes, independe da rota que a aplicação está. Inclusive, se você não quiser nem usar rotas, você não precisa. Dá pra fazer tudo sem rotas, juro!\nNão precisa ser o maníaco das rotas. Se desprenda delas e promova mais reatividade com os seus componentes. Comece a otimizar suas rotas hoje mesmo!\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu quero continuar instigando sua curiosidade pra que você me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter que eu tô bolando pra te avisar quando os próximos conteúdos ficarem prontos e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida sobre qual metodologia usar naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este. Você também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player. Vem trocar ideia!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2018-03-01T00:00:00",
            "titulo": {
                "resumido": "Máquina de estados",
                "completo": "Estados, Reatividade e Programação funcional - P1"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep4-maquina-de-estados.mp3",
            "duracao": "14:36",
            "descricao": "Gerência de estados tem sido um assunto da atualidade, principalmente se você está envolvido com Javascript e toda velocidade do nosso ecossistema gigantesco, com certeza, pelo menos já se deparou com algo sobre. Esse será o primeiro tópico a ser abordado hoje. Se você ainda não sabe o que é uma máquina de estado ou mesmo se sabe mas ainda não tem usado, chegou a hora de começar a admitir que terá que usar. E já te adianto, é um caminho sem volta. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\nEste é o quarto episódio de um podcast sobre programação que não consegue sair do processo de construção.\n\nEste é o ELEMENCAST e eu, Luigui Delyer, tenho trazido alguns drops de conteúdos legais sobre programação, Front-end, Javascript, CSS, HTML5, metodologias de projetos, componentização, nodejs, mapas e gis, programação funcional entre outras coisas maneiras.\n\nPra quem me deu diversos feedbacks sobre escutar o podcast pelo navegador do celular, eu sei que ainda não fiz a versão responsiva, paciência tá quase! Uma coisa de cada vez. Se você está no celular e quer um pouco mais de controle sobre o áudio, eu te indico que você use algum App desses especializados em podcasts, eu cadastrei todo conteúdo em todos os Apps que encontrei e se por acaso você não conseguir ouvir no seu App favorito, me dá um toque! Você também pode assinar o Feed RSS que tem na capa do site pra sempre ficar por dentro dos novos conteúdos que eu coloco por aqui, além de sempre ter a possibilidade de baixar o MP3 do episódio pra ouvir quando quiser.\n\nEu preciso agradecer também a todos que me apoiaram e me cobraram novos conteúdos aqui, a vontade de vocês me incentiva a continuar.\n\nNo primeiro, segundo e terceiro episódio, eu falei sobre uma metodologia diferente, o Atomic Design! E se você perdeu algum episódio, é só dar uma conferida, vale a pena.\n\nEssa é a primeira parte de um assunto que foi separado em três partes: Gerência de estados, reatividade e programação funcional no front.\n\nAssim como eu sempre faço um paralelo com a ciência da matéria no Atomic Design, esses termos aí também podem ser paralelizados com o fato de que nós, seres humanos, muitas vezes reagimos de maneiras diferentes conforme os estímulos que recebemos. Nós somos orientados a eventos e por muitas vezes, diante de muitas situações os afetos provocados pelo ambiente onde estamos, alteram nosso estado emocional.\n\nGerência de estados tem sido um assunto da atualidade, principalmente se você está envolvido com Javascript e toda velocidade do nosso ecossistema gigantesco, com certeza, pelo menos já se deparou com algo sobre.\n\nEsse será o primeiro tópico a ser abordado hoje. Se você ainda não sabe o que é uma máquina de estado ou mesmo se sabe mas ainda não tem usado, chegou a hora de começar a admitir que terá que usar. E já te adianto, é um caminho sem volta.\n\nEm Javascript nós possuímos algumas implementações famosas que gerenciam estados.\nA que eu acredito ser a mais conhecida, é a Redux, que se define como uma máquina de estados previsíveis para aplicativos JavaScript. O objetivo dela é te ajudar a escrever aplicações que se comportam de forma consistente, funcionam em diferentes ambientes de desenvolvimento, como clientes, servidores e ambientes nativos que são fáceis de serem testadas. Você pode usar o Redux diretamente com React ou de forma agnóstica em qualquer aplicação JS. O Redux possui uma extensão para o DevTools do Firefox e do Chorme que te permite 'viajar no tempo', ou seja, ir pra frente e pra trás nas ações que o usuário fez enquanto usava a aplicação. E isso é super maneiro, além de ser muito útil.\n\nOutra implementação conhecida atualmente é exclusiva para VueJS, a Vuex. Na minha própria concepção, como Vuex é preso e dependente direto de VueJS, a biblioteca pode se tornar mais poderosa e mais completa que Redux por diversos fatores. Ela se define como um padrão de gerenciamento de estados que serve como um centralizador das informações para todos os componentes. Suas regras internas garantem que o estado da aplicação só possa ser mudado de forma previsível. Assim como Redux, Vuex possui uma extensão para o DevTools do Firefox e do Chorme. Além de você 'viajar no tempo' da aplicação, você pode exportar e importar estados prévios. Acredite, isso ajuda MUITO durante o debug e no tempo de desenvolvimento de uma grande aplicação. Imagina só que você pode reproduzir uma série de ações do usuário até encontrar um determinado bug, ou que até, não precisa ficar fazendo X interações com a aplicação a cada refresh do navegador.\n\nA terceira mais famosa implementação de gerência de estados (e a mais recente) é a ngRX (que é a junção do Redux com RxJS) e é exclusiva para Angular. A biblioteca elenca suas qualidades começando pelo fato de que o estado é uma estrutura de dados única e imutável, que as ações definem as mudanças no estado, e que as funções responsáveis pelas alterações no estado são puras. Como por baixo do capô dela nós temos o Redux, quem já está acostumado com ela e está trabalhando com Angular, não terá problema algum em usar a biblioteca. Da mesma maneira, você poderá usar a extensão do Redux para o DevTools dos navegadores.\n\nA proposta de todas essas bibliotecas é sempre a mesma. Acho que isso ficou bem claro nas suas definições. Todas elas querem te ajudar a gerenciar o estado da aplicação de forma consistente, pura, funcional, imutável e consequentemente, promover a tal reatividade entre seus componentes. Ou seja, esses caras pegam a responsabilidade das informações de todos os seus componentes e te força a descolar uns dos outros, criando diversos gatilhos para que os dados do seu componente possam ir de um lado para o outro de uma forma única, imutável e direcional.\n\nTá, mas aí você pode me dizer que até hoje fez suas aplicações com React, Vue ou Angular sem usar nada disso e que todas funcionam muito bem, obrigado. Ok, realmente não posso discordar de você, todas realmente devem funcionar. Gerência de estado não é bala de prata, mas nada é. Porque então devemos usar uma máquina de estado, ou melhor, quando devemos usar?\n\nO primeiro sinal que você precisa identificar é a quantidade de componentes que você tem na sua aplicação, é um número grande? Se você já caiu de cabeça no Atomic Design, nós sabemos que sim, você terá vários componentes. Talvez até um número que nós dois tenhamos vergonha de falar por aí porque pode parecer loucura.\nOutro sinal é a 'árvore genealógica' que seus componentes formam, por exemplo, quando você tem um componente pai que chama um componente filho, que reage num componente neto e que a interação do usuário provocará uma reação no componente tio! Bizarro isso, né?\nOu até se mesmo assim você conseguir disparar esses eventos todos chamando de trás pra frente o fluxo dos dados, você consegue imaginar a panela de espaguete que está construindo? Esse App, com certeza vai trazer dores algum dia que você precisar desmontar esse castelo de cartas aí.\n\nOutro ponto importante que você precisa pensar é se o seu fluxo de dados está preso a sua interface, a partir do momento que as informações que você tem, são somente as que estão renderizadas na tela, você precisará se esforçar muito mais pra fazer que as informações fluam para que assim novas telas apareçam. Da mesma maneira, se seu estado estiver distribuído somente na sua interface nos componentes já renderizados, a qualquer mudança desse estado, você terá de 'inundar' todos os componentes com as alterações para que sua informação chegue no destinatário correto.\n\nÉ como aqueles hub's de rede antigos, lembra? (Se você nasceu em 90, e conseguiu acompanhar o começo da internet, com certeza você sabe do que eu tô falando). Esses hub's simplesmente não sabiam quem eram os computadores ligados a eles e então, eles simplesmente 'inundavam' a rede toda e todas as máquinas atrás do destinatário. Consegue imaginar a latência e a lentidão que isso provocava? Pois é, isso acontece nesse seu App gigante aí que ainda não tem gerência de estado isolada dos componentes.\n\nQuando você não tem ninguém que está por fora dos seus componentes gerenciando os dados, você também é obrigado a passar diversas vezes um mesmo valor pelas propriedades do componente até que ele chegue no seu destinatário. Com esse cenário completo, fica evidente que 'debugar' esse aplicativo será um inferno.\n\nSe por acaso, o App que você está trabalhando agora não faz parte de nenhum desses cenários, então definitivamente você não precisa usar uma máquina de estados.\n\nUm dos pontos que eu acho importante ressaltar, é que máquinas de estado são verbosas e se você é daqueles programadores que odeiam burocracia, nem tente, você vai odiar esse ponto. Porém, se você é aquele tipo de programador que quer performance, interoperabilidade, escalabilidade, consistência e clareza no seu código, você vai amar trabalhar com uma máquina de estado finito.\n\nE como funciona o fluxo de dados dentro dessas coisas? Como fica a parte prática disso? Bom, como eu exemplifiquei somente Redux e Vuex, vou te contar como funcionam estas bibliotecas, o que claramente não resume todas as implementações disponíveis.\n\nNo Redux, a regência do estado fica separada em 3 camadas, no Vuex em 4. Eu vou tentar fazer um paralelo entre os dois e explicar as diferenças de cada uma delas, então se liga só:\n - O centralizador das informações, onde todos os dados da aplicação estão ali disponíveis para todos os componentes, no Redux chamamos de Store, no Vuex chamamos de State.\n - As funções puras que tem a capacidade e autoridade de alterar o estado da aplicação são os Reducers no Redux e as Mutations no Vuex. Essas funções são responsáveis por receberem os valores da sua aplicação, modificarem o estado e registrarem um estado completamente novo na memória.\n - Os invocadores das funções que alteram o estado são chamados de Actions nas duas bibliotecas. Porém, elas possuem uma diferença em cada uma delas. No Vuex elas são naturalmente assíncronas e devem ser responsáveis pelas requisições externas nas API´s que você estiver utilizando. No Redux é quase a mesma coisa, porém a diferença fica na implementação do código em si. Você precisa fazer algumas etapas a mais pra deixar sua Action assíncrona. Vale lembrar que é super importante que seus Ajax estejam sempre dentro da máquina de estados. Ela deve ser responsável pode solicitar, receber, tratar e armazenar os dados e não os seus componentes.\n - Entre as duas bibliotecas existem uma diferença gigantesca e que pra mim faz todo sentido. No Vuex nós temos uma camada a mais que são os Getters. Esses caras são funções puras, assim como as Mutations, porém, elas tem uma função contrária. Elas são responsáveis por processar a retornar um pedaço do estado. Ou seja, com um Getter você consegue apontar pra pedaços isolados do estado de dentro do seu componente sem precisar se preocupar com a validação do dado. Essas validações acontece Getter em si. No VueJS, o Getter é o cara responsável por promover a reatividade perfeita no componente.\n\nTendo isso tudo em mente, já dá pra ter uma ideia, de que em qualquer momento, qualquer componente pode invocar uma situação da máquina de estados e que ela por sua vez terá o papel de centralizadora da verdade. Tudo que passa por ela e está nela, é certamente confiável e consistente.\n\nVocê começará a perceber que assim, seus componentes se tornam ainda mais independentes, funcionais e puros. A qualquer momento você pode simplesmente substituir qualquer componente pois a lógica dos dados está dentro do estado da aplicação e não mais no componente. Ele servirá apenas pra renderizar o layout na tela e receber as interações do usuário.\n\nTrazendo para o nosso cenário do Atomic Design, isso se encaixa perfeito pelo fato de termos milhares de componentes pequenos, falando a mesma língua de forma independente e coesa.\n\nA reatividade provocada de forma natural pela máquina de estado será o nosso próximo tema. Vou aprofundar ainda mais no assunto para exemplificar o fluxo do estado atualizando nossa View de forma uniforme e direcional.\n\nEu gostaria de frisar que tentei, de verdade, desconectar programação reativa de programação funcional. Do mesmo jeito que tento desconectar componentização real de Atomic Design e não consigo. Se você não gosta desses termos ou ainda não sacou que o próximo hype do front são justamente esses, eu preciso te dizer que tá na hora de aceitar a onda e cair nela, pra não cair de cima dela.\n\nVocê sabe tão bem quanto eu que nós programadores de Front-End, vivemos de hype. Hypes pra todo lado! E em 2018 será a vez de mergulharmos de cabeça em reatividade, controle de estados e programação funcional. É só vermos que GraphQL tem se tornado o novo padrão de comunicação entre front e back e que algumas outras ferramentas de tipagem como Flow e Typescrpit tem ganhado força em tão pouco tempo. Da mesma maneira temos Elm e ReasonML levando o front pro mundo funcional com força. Precisamos estar atentos a todas essas coisas novas que estão acontecendo no mercado. Jajá essas coisas serão requisitos em vagas.\n\nBom, o que eu tinha pra te dizer hoje era isso. Eu quero continuar instigando sua curiosidade pra que você me ajude a fazer este podcast ficar ainda mais legal. Eu também preciso que você deixe o seu e-mail aí em baixo do player pra você ficar por dentro da newsletter do podcast, eu sempre aviso quem tá lá primeiro quando sai um novo episódio e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo ou até pro seu chefe que tá em dúvida se coloca uma máquina de estado naquele projeto novo da empresa.\nVocê pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você pode baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este. Você também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player no site.\n\nVem trocar ideia!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2018-10-14T00:00:00",
            "titulo": {
                "resumido": "BrazilJS",
                "completo": "Eventos importantes da comunidade Javascript BR - P1"
            },
            "subtitulo": "Parte 1",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep5-braziljs.mp3",
            "duracao": "10:21",
            "descricao": "Começando pela BrazilJS, eu inicio te dizendo que se você nunca foi... Sério! Se organiza e vai no ano que vem... Você realmente não faz ideia do que tá perdendo. O networking é incrível, o conteúdo é incrível, a estrutura é impecável e acima de tudo, é um ambiente seguro. Você mulher que me ouve, você pertencente a qualquer grupo subrepresentado, vem também, por favor! Queremos você lá! A diversidade faz o evento ser ainda melhor e a BrazilJS é o local perfeito pra todo mundo. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\nEste é o quinto episódio do elemencast, o meu podcast sobre programação.\n\nEu, Luigui Delyer, tenho trazido alguns drops de conteúdo sobre Front-end, Javascript, CSS, HTML5 e qualquer outra coisa que eu achar maneira.\n\nDepois de um bom tempo sem postar aqui e depois de ter apagado do meu HD dois episódios prontinhos, gravados e editados e esta ser a terceira vez que eu gravo este episódio, eu faço hoje um episódio especial.\n\nMas antes de qualquer coisa, eu tenho umas novidades pra te contar. A primeira e a mais importante delas é que agora o elemencast está no Spotify! Isso mesmo! Você pode desfrutar dos áudios numa ferramenta bem mais completa. Por lá você pode favoritar os episódios que mais gostou, seguir o perfil para receber novos conteúdos, baixar os áudios, controlar a velocidade de reprodução, pausar, voltar, enfim... Você já sabe como o Spotify funciona. Se por acaso você não é assinante da plataforma, não se preocupe porque a segunda novidade é que você também pode encontrar o elemencast no Google Podcasts, que é uma ferramenta gratuita para Android e que tem as mesmas vantagens do Spotify, além de possuir um catálogo gigantesco com outros canais. Se você não tem Android e tá num iOS, você também pode ter esse controle todo no iTunes, por lá você também poderá encontrar todo material que eu disponibilizar. E por fim, a última novidade é que até que enfim este podcast tem uma versão responsiva! E o melhor de tudo? Eu recebi um PR do meu grande amigo Gustavo Teodoro (Instagram @gustavoteobr) e graças ao código dele, agora é possível usar de boas no celular.\n\nEntão eu já te peço logo de cara que você compartilhe o podcast e me ajude a espalhar a sementinha maluca do front-end nos teus amigos.\n\nMas agora voltando ao assunto deste episódio eu vou separá-lo em duas partes. Eu tô aqui pra falar sobre o meu resumo pessoal da BrazilJS e como foi ter participado do VueJS Summit em São Paulo.\n\nComo esses dois eventos são importantíssimos pra toda comunidade Javascript, acho que um episódio dedicado a isso vale muito! Mas não pensa que eu esqueci sobre o assunto que estava falando no episódio anterior. Se você não lembra qual era ou se chegou agora e ainda não ouviu, vale a pena voltar e ouvir. Eu comecei uma série de três episódios e o primeiro foi sobre Gerência de estados. Os próximos, que virão depois desta sequencia serão sobre reatividade e programação funcional no front, qual é o estado atual desse assunto e quais são as alternativas disponíveis hoje.\n\nComeçando pela BrazilJS, eu inicio te dizendo que se você nunca foi... Sério! Se organiza e vai no ano que vem... Você realmente não faz ideia do que tá perdendo. O networking é incrível, o conteúdo é incrível, a estrutura é impecável e acima de tudo, é um ambiente seguro. Você mulher que me ouve, você pertencente a qualquer grupo subrepresentado, vem também, por favor! Queremos você lá! A diversidade faz o evento ser ainda melhor e a BrazilJS é o local perfeito pra todo mundo. Então fica ligado e quando começarem às vendas, corre logo nos primeiros lotes pra depois não dar a desculpa de que ficou caro e não dá pra ir. Já vai avisando seu chefe, pedindo patrocínio da empresa e vai! Sério!\n\nO evento dura dois dias e esse ano, participei de uma comitiva de amigos que decidiu pegar um AirBNB pra diminuir os custos de hospedagem, aliás, essa é uma excelente dica. Se você não está acostumado com isso de ficar em hotéis, essa é uma solução ótima tanto no valor pago, quanto no serviço entregue. Outra opção também é ficar em hostels, muitos desenvolvedores que vão pros eventos no Brasil todo fazem isso, eu já fiz isso, mas como agora minhas horas de sono ficaram muito caras, eu prefiro escolher um lugar silencioso pra dormir. Essa comitiva foi formada por mim, o moço do React, o Raphael Amorim (Twitter @raphamorims) (que um dia vai vir aqui falar sobre essa lib famosinha do facebook e sobre as loucuras que ele faz usando ela), o Diego Leite (Instagram @diegoleit3) lá da Bahia e o Matheus Lima (Twitter @matheusml), diretamente da Noruega brasileira, Niterói, no Rio de Janeiro. Além destes, em outra caravana estavam meus amigos que moram no Rio e colaram junto! Vale o destaque pro Josh (Instagram @josh_rezende), o Matheus Mesquita (Twitter @_mathmesquita) e do Nando Sangenetto (Twitter @NandoSang).\n\nChegamos lá na quinta feira, um dia antes do evento e fomos fazer o reconhecimento das terras gaúchas. Assim que saímos do aeroporto, já encontramos um grupo de devs que se reuniu através de um supergrupo no Telegram focado em organizar alguns rolês com o maior número de pessoas possível. Pra vocês terem uma ideia, 118 pessoas estavam no grupo debatendo e sugerindo lugares pra conhecermos em Porto Alegre, e com isso, eu conheci gente pra caramba e obviamente não vou lembrar o nome de todo mundo, então só vou destacar alguns, não me odeiem.\n\nA primeira parada foi numa churrascaria pra receber as boas vindas do povo do Uruguai do Norte e lá, os contatos pessoais já foram acontecendo com gente que eu admiro e nunca tinha visto ao vivo! Logo de cara eu já tive o privilégio de conhecer pessoalmente a Aline Bastos (Twitter @AlineBastos), a Alda Rocha (Twitter @mjcoffeeholick) e o Rafael Specht (Twitter @rafael_sps) (tomara que eu tenha dito seu nome certo, cara, se eu não disse, foi mal), pessoas importantíssimas na comunidade de desenvolvimento e que fazem diferença por onde passam.\n\nO rolê da noite foi num bilhar maravilhoso que fica próximo à tão conhecida 'Cidade baixa'. Que lugar meus amigos, que lugar! Assim que chegamos, já nos deparamos com sei lá, umas 50 pessoas que já estavam em POA para o evento e meu, que incrível!\n\nNesse mesmo encontro, eu conheci o tão famoso Felquis (Twitter @felquis) e também o pessoal incrível de um outro podcast, o Quebradev (Twitter @quebradev)! Estavam lá o Kaio, o Gustavo e o Matheus (só faltou o Reginaldo que não foi, mancada). Em breve, eles estarão aqui no elemencast pra falar sobre inclusão e algumas outras realidades do mundo dos Devs. Se você ainda não conhece o podcast desses caras, trata de colocar na sua lista agora mesmo! O endereço deles é simples: quebradev.com.br.\n\nTudo pronto pro primeiro dia e aí foi onde a mágica começou! A organização do evento, liderada pelo Jaydson (Twitter  @jaydson) e pelo Felipe (Twitter @felipenmoura), surpreendeu por mais um ano consecutivo. A fila do credenciamento que o ano passado foi um transtorno pra algumas pessoas, esse ano simplesmente não existiu! Eles conseguiram fazer de uma maneira extremamente rápida e eficaz e todo mundo ficou muito confortável rapidamente.\n\nAssim que eu desci as escadas do Barra Shopping Sul, me deparei com uma espécie de estúdio de TV montado pelo pessoal e eu não tinha entendido muito bem. Quando o evento começou, eu vi uma das coisas mais incríveis no quesito apresentação de eventos de TI. Eles tiveram uma sacada maravilhosa de convidar o pessoal do DevNaEstrada, um dos podcasts mais famosos do Brasil da nossa área, pra apresentarem e fazerem a conexão entre quem estava em casa, com quem estava no evento e caras, isso ficou MUITO bom! Tão de parabéns ao extremo.\n\nA extrutura interna do palco e acomodações também surpreenderam. Mais cadeiras, mais lugares e uma arquibancada excelente abraçando aquele telão enorme e o palquinho discreto que recebeu os palestrantes deste ano.\n\nA decoração estava incrível, a variedade dos brindes, o coffee e os estandes, tudo impecável como sempre. Mais uma vez a BrazilJS se consolidou como o maior evento de JavaScript do universo.\n\nSobre as palestras desse dia, eu destacaria a da Ada Rose Cannon, sobre 'As intersecções das novas Web APIs', a do Mario Souto sobre 'Extendendo o CSS com JavaScript' porém, onde ele fala especificamente sobre o futuro do CSS com o Houdini e a do (nossa, é impossível falar esse nome e morar no Brasil ao mesmo tempo, mas vamos lá, vou tentar) István Szmozsánszky, mas vamos chamar ele só de Flaki, que falou sobre IoT com JavaScript.\n\nO rolê da noite ficou por conta daquele grupo do Telegram, mas na real, muita gente acabou seguindo pra cantos diferentes e o grupinho que eu tava, curtiu pela Cidade Baixa, o point oficial de POA.\n\nNo segundo dia de evento, as palestras que mais chamaram minha atenção foram as do Benjamin Wilhelm, que falou sobre como o The New York Times revolucionou a forma com que consumimos conteúdo jornalístico com Realidade Aumentada e ele disse uma frase que pra quem tá construindo aplicações com Realidade Virtual e Aumentada faz muito sentido e me fez pensar por um tempo sobre ela. A frase é: 'Caminhar é a nova forma de rolar uma página', pense nisso. A palestra da Evangelina Ferreira sobre acessibilidade e como estamos quebrando a web cada vez mais, foi muito esclarecedora sobre o assunto e pra fechar o evento, a palestra do Rafael Specht foi daquelas que a gente fica com os olhos brilhando né... Mas também, o cara é Rock Star, sabe dar espetáculos. Ele simplesmente usou ninguém mais, ninguém menos que o David Bowie como personagem principal da palestra e mostrou como que podemos misturar imagens via Canvas com WebAudioAPI e tocar as cores ou manipular as imagens com efeitos de áudio. Ainda por cima, colocou uma guitarrinha no palco e deu um show a parte tocando umas coisinhas pra todo mundo vibrar.\n\nE como a tradição do evento manda, o after aconteceu na Cidade Baixa de Porto Alegre e como sempre, foi ótimo! Muita gente do Mundo todo em torno de aprender mais, fazer novos amigos e trocar experiências de uma forma única.\n\nSem dúvida alguma, a BrazilJS fez história mais uma vez e já nos deixa com saudade, ansiosos pelo ano que vem!\n\nSe de fato você não pode participar da BrazilJS por algum motivo, relaxa, dá pra ver o conteúdo todo de graça no Youtube, lá no canal do evento, os dois dias estão inteiros lá e eles já começaram a lançar as palestras isoladamente também. Aproveita e se inscreve no canal do pessoal que toda semana eles soltam a Weekly em vídeo, sempre com um conteúdo maravilhoso!\n\nBom, o que eu tinha pra te dizer sobre esse evento era isso. Agora continua aí que o próximo episódio é sobre a minha participação no VueJS Sumit que rolou em São Paulo!\n\nMe ajude a fazer este podcast ficar ainda mais legal. Eu preciso que você deixe o seu e-mail aí em baixo do player no site e eu prometo que não faço SPAM, isso é só pra você ficar por dentro da newsletter do podcast, eu sempre aviso quem tá lá primeiro quando sai um novo episódio e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo que nunca foi na BrazilJS e tá precisando de um bom incentivo.\n\nVocê também pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você poderá baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\n\nVocê também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player no site, ou simplesmente me buscar por @luiguild.\n\nVem trocar ideia!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui. Até a próxima."
        },
        {
            "data": "2018-10-14T00:00:00",
            "titulo": {
                "resumido": "VueJS Summit",
                "completo": "Eventos importantes da comunidade Javascript BR - P2"
            },
            "subtitulo": "Parte 2",
            "participantes": [
                {
                    "foto": "/static/img/participantes/luigui.png",
                    "nome": "Luigui Delyer",
                    "email": "elemencast@s1x.com.br",
                    "github": "https://www.github.com/luiguild",
                    "twitter": "https://www.twitter.com/luiguild",
                    "minibio": "Ativista de Software Livre, Mozilla Reps, GeoDeveloper apaixonado por mapas e data-visualization.\nFrontEnd do time de inovação na Webradar, uma empresa que trabalha com BigData e IoT Analytics. No trabalho, uso e adoro Vanilla JavaScript, VueJS, AngularJS, PugLang, LESS e SASS. Já fui designer gráfico e curto UI. De vez em quando cozinho e tenho vida além da informática. Sou daqueles que dançam ouvindo música enquanto trabalha."
                }
            ],
            "audio": "/static/audio/ep6-vuejssummit.mp3",
            "duracao": "08:58",
            "descricao": "O evento teve a duração de dois dias e foi separado de duas formas, um dia exclusivo para workshops e outro dia para a conferência com os palestrantes em si. Para os workshops, tivemos dois gratuitos especiais para mulheres e pessoas que se identificam como tal, e outros três pagos com membros do core team do Vue e também com um engenheiro do Gitlab. Se você ficar com alguma dúvida, pode abrir uma issue lá no repositório do podcast que eu vou te responder! Me segue nas redes sociais (@luiguild) e vem trocar ideia comigo! Uma comunidade forte, é uma comunidade unida que se ajuda.",
            "texto": "Oi!\nEste é o sexto episódio do elemencast, o meu podcast sobre programação.\n\nEu, Luigui Delyer, tenho trazido alguns drops de conteúdo sobre Front-end, Javascript, CSS, HTML5 e qualquer outra coisa que eu achar maneira.\n\nComo havia dito no episódio anterior, esta aqui é a segunda parte dedicada aos eventos que participei recentemente, a BrazilJS e o VueJS Summit. Então, se você não ouviu a primeira parte sobre a BrazilJS, volta aí um episódio e ouve também!\n\nSobre o VueJS Summit, eu preciso começar agradecendo Thaíssa Candella (Twitter @ThaissaCandella) e o Igor Halfeld (Twitter @igorhalfeld), os organizadores do evento que deram a cara e fizeram acontecer esse que foi o principal evento de Vue já realizado no Brasil. Além deles, eu não posso deixar de agradecer o empenho de todas as pessoas que estavam ao lado deles, obviamente não tem como eu citar o nome de todos, então, sintam-se abraçados também. Da mesma forma, eu incluo as empresas que patrocinaram, apoiaram e incentivaram a iniciativa de alguma forma.\n\nO evento teve a duração de dois dias e foi separado de duas formas, um dia exclusivo para workshops e outro dia para a conferência com os palestrantes em si. Para os workshops, tivemos dois gratuitos especiais para mulheres e pessoas que se identificam como tal, e outros três pagos com membros do core team do Vue e também com um engenheiro do Gitlab.\n\nE falando nisso, o evento mandou bem demais se esforçando pra trazer gente grande pra falar para o público presente e também quem tava acompanhando pela internet. Ao todo, tivemos a presença de três core-commiters do Vue, o Chris Fritz, o Edd Yerburgh e o Eduardo San Martin que é mais conhecido como Posva na internet. A Diana Rodriguez, diretora da Vue Vixens e Developer Advocate da Progress a empresa criadora do NativeScript também participou do evento. Ainda tivemos as presenças do Google Developer Expert, Gerard Sans e o Jacob Schatz, engenheiro do Gitlab, além do grandioso Maujor e de uma galera sensacional do Brasil inteiro. Até eu tive a oportunidade de falar um pouquinho sobre as minhas loucuras relacionadas ao Atomic Design.\n\nDesde o coffee até a estrutura toda do evento, tudo estava dando gosto de ver! As palestras até tiveram espaço pros participantes fazerem perguntas e interagirem com os palestrantes, tanto quem estava remoto, quanto quem estava presente. Tá certo que isso acarretou num atraso entre as palestras, mas é aceitável, por que todo mundo queria extrair o máximo de quem estava ali disposto a passar o melhor conteúdo do mundo sobre o assunto.\n\nO evento inovou muito tendo o ingresso para participação remota, online e funcionou muito bem! Todos os participantes receberam certificados e puderam interagir via web com os palestrantes durante as palestras.\n\nDo conteúdo apresentado por todos os palestrantes, eu gostaria de destacar algumas talks específicas, obviamente que nenhuma foi de baixo nível, mas não dá pra eu falar de todas, então dentre elas, eu começo com a palestra do Chris Fritz, que fez a abertura do evento e já deixou todo mundo ansioso com as novidades do Vue, tanto as do DevTools, quanto qual é o caminho que a biblioteca ainda tem pra trilhar. Muitas novas ferramentas foram apresentadas de antemão e anunciadas pra todo público presente, dentre elas a minha favorita é o debugger do roteador. Daqui a pouco tempo, nós poderemos debugar rotas, props e tudo que envolva as funções de roteamento de uma forma limpa e simplificada. Todas essas ferramentas já estão disponíveis para serem usadas em Alpha e Beta, se você gosta de viver perigosamente, vai lá na organização do VueJS no Github e instala tudo!\n\nA segunda que eu pontuo é a do Jacob Schatz, o engenheiro do Gitlab, ele nos mostrou como funciona o Vuex por dentro e ao mesmo tempo, como tudo é simples. Ele realmente foi lá no código fonte do Vuex mostrar como as coisas funcionam e como devemos fazer algo ou qual é o impacto do que fazemos no final de tudo. Ele desmistificou grandes pontos que eu pessoalmente tinha com o Vuex e ainda ensinou técnicas de performance que pra mim, foram excelentes!\n\nOutra que com certeza fez todo mundo ficar atento e orgulhoso ao mesmo tempo foi a do Maujor, que como sempre, nos encheu de conteúdo de qualidade. O cara que leva como marca registrada o título de Dinossauro do CSS, tá se tornando um monstro em Vue! E o que o Maujor viu no Vue ficou muito claro pra todo mundo que já usa a biblioteca: O Vue é simplesmente como a Web é. Nós não quebramos a web quando usamos Vue.\n\nA palestra super técnica do Edd Yerburgh sobre testes unitários, desmistificou o assunto pra muita gente e de quebra ainda garantiu que muitas pessoas ali (e eu me incluo nessa lista), aprendessem de fato sobre testes unitários e como usar o Vuex neles. Quem me conhece, sabe que eu não sou a pessoa mais fã de testes do mundo.\n\nO BR Caio Incau mostrou técnicas e formas de otimização de código através do webpack e cara, que incrível! O webpack por si só é uma ferramenta gigantesca, acho que você sabe disso, e até mesmo por conta disso, ela nos permite navegar por um oceano de opções e nem sempre dá pra ficar sabendo de tudo.\n\nO meu grande amigo, William Marques, que também é BR deu um show explicando tim tim por tim tim sobre aplicações modulares. Eu que sou o fissurado por ir quebrando tudo em pedacinhos, não sabia de tudo aquilo que ele acabou exemplificando ali. O que eu mais gostei, foi que ele aprofundou de fato em casos de usos reais de mixins, extends, componentes dinâmicos, módulos, render functions, services e as melhores maneiras de manipulação do protótipo do Vue. Ficou irado!\n\nAo final do dia, eu encerrei o evento falando sobre Atomic Design e porque o Vue é a biblioteca perfeita pra isso. Pra quem me acompanha aqui no podcast, sabe boa parte do que eu penso sobre esse tema e quem me conhece pessoalmente sabe o quanto sou apaixonado por ele. Atomic Design pra mim é o cenário ideal pra componentização no front e eu mostrei um pouco disso lá. Acho que talvez o pessoal tenha ficado mais impressionado com o slide que eu mostrei sobre como fica a orquestração de comunicação entre componentes utilizando o Vuex. O mais sensacional pra mim, foi ver a quantidade de gente que veio me dar ideias sobre isso, vocês não fazem ideia o quanto eu já expandi isso na minha cabeça maluca... Eu cheguei na conclusão que eu preciso aumentar aquele slide... Foi tanta ideia maneira que eu tô pensando seriamente até em soltar um artiguinho no medium só sobre comunicação de componentes utilizando Atomic Design e Vuex, talvez eu solte, não vou prometer nada.\n\nMas pra você ficar sabendo sobre isso, se inscreve na newsletter que tem na capa do site do elemencast que eu vou avisar por lá também e ainda nesse tema, se você quer aprender ou reforçar um pouco mais o que você já sabe sobre Atomic Design, recomendo fortemente que você ouça os dois primeiros episódios do elemencast onde eu abordo o tema de uma forma bem legal.\n\nPra fechar com chave de ouro o evento, além dos vários brindes sorteados pela organização, os palestrantes ganharam uma plaquinha de participação, tipo um troféu, e ela tá muito bem posicionada aqui na minha mesa me deixando bem orgulhoso por ter feito parte deste maravilhoso evento da nossa comunidade! Esse é o momento do VueJS e nós vamos aumentar isso ainda mais!\n\nEsse evento só serviu pra mostrar o quanto nossa comunidade é forte e unida. Estando ali eu senti isso de verdade! Eu conheci ao vivo, pessoas que já admirava demais pela internet como o William Marques, o Patrick Stival, o Igor Halfeld e o Manoel Freitas, além de várias outras pessoas que não tenho como lembrar o nome agora. E não poderia deixar de citar a presença marcante do grande Vinicius Reis, do Ronalson e do Lucas Trindade que são meus amigos aqui do Rio e que também foram de caravana pra lá.\n\nSe você curte VueJS ou se você tá querendo aprender mais sobre a biblioteca, você pode se juntar a nós no nosso grupo do Telegram, é só colocar lá na busca @vuejssbrasil, hoje nós já somos 2,3k pessoas unidas em prol de debater tudo que gira em torno de VueJS e JavaScript, então cola lá com a gente!\n\nSe de fato você não pode participar do VueJS Summit por algum motivo, daqui um tempinho os vídeos das palestras serão divulgados na íntegra, é só ficar ligado lá no grupo do Telegram e aqui no podcast que eu vou avisar. Pra você que foi, as fotos oficiais do evento já foram divulgadas lá na fan page do facebook, vai até lá e se procura, quem sabe os fotógrafos do evento te deixaram na história.\n\nBom, o que eu tinha pra te dizer sobre esse evento era isso.\n\nMe ajude a fazer este podcast ficar ainda mais legal. Eu preciso que você deixe o seu e-mail aí em baixo do player no site e eu prometo que não faço SPAM, isso é só pra você ficar por dentro da newsletter do podcast, eu sempre aviso quem tá lá primeiro quando sai um novo episódio e é claro, preciso da sua colaboração enviando este conteúdo pro seu amigo mais próximo que não pôde ir ao VueJS Summit.\n\nVocê também pode me ajudar diretamente indo até o Github do ELEMENCAST e abrindo uma issue sobre o que você quiser, por lá podemos conversar diretamente e você poderá baixar qualquer episódio que eu liberar, todos estarão lá, inclusive este.\n\nVocê também pode falar comigo diretamente acessando alguma das minhas redes sociais que estão aqui em baixo do player no site ou me procurando em qualquer lugar como @luiguild.\n\nVem trocar ideia comigo!\n\nUma comunidade forte, é uma comunidade unida que se ajuda.\n\nMuito obrigado até aqui e até a próxima."
        }
    ]
}
